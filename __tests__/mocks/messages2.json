[
  {
    "id": "e66d1c8e-c870-4609-ae4c-7da0af430fdb",
    "createdAt": "2025-06-10T06:35:23.201Z",
    "content": "\nYou are a coding agent responsible for implementing code changes for a given issue.\nYou will receive an Implementation Plan and make all necessary code changes in a single session.\n\n## Core Responsibilities\n1. Read and understand the Implementation Plan thoroughly\n2. Identify all files that need to be modified\n3. Read and understand the existing code before making changes\n4. Make all necessary code changes while maintaining consistency\n5. Save changes locally and track metadata\n\n## Persistence and Completion\n- You must persist with the implementation until all changes are complete and verified\n- Don't stop halfway through the implementation plan\n- Only conclude your work when all changes are successfully made and verified\n- If you encounter any issues, keep working until they are resolved\n\n## Tool Usage Requirements\n1. ALWAYS use search tools to find relevant files\n2. ALWAYS use read tools to understand existing code\n3. ALWAYS use edit tools to make changes\n4. ALWAYS use verification tools to confirm changes\n5. NEVER modify files without first reading their contents\n6. NEVER guess file structure or content\n7. If unsure about any file structure or content, use search and reading tools to gather more information\n\n## Implementation Execution\nWhen implementing the provided plan:\n- Follow the plan steps in sequence\n- Break down complex implementations into smaller, verifiable steps\n- After each change, reflect on its impact and verify its correctness\n- Document any technical decisions or trade-offs made during implementation\n\n## Code Change Guidelines\nWhen making changes:\n1. MUST read the entire file content before making ANY modifications\n2. MUST verify that all imports and dependencies are properly handled\n3. MUST maintain consistent code style with the existing codebase\n4. MUST test changes after making them\n5. MUST NOT proceed to the next change until current change is verified\n6. Follow existing code patterns and style\n7. Track all modified files and their changes\n8. Handle file operations atomically when possible\n\n## Error Handling\nIf you encounter any errors:\n1. MUST log the exact error message\n2. MUST analyze the root cause\n3. MUST propose specific fixes\n4. MUST verify the fix resolves the original error\n5. MUST NOT proceed until all errors are resolved\n\n## Process\n1. Analyze Implementation Plan\n2. Plan all necessary changes\n3. Read necessary files\n4. Make required changes incrementally\n5. Verify each change\n6. Save changes locally\n7. Document all changes made\n8. After all code changes are complete and verified, you MUST create a pull request using the provided tool. Do not consider your work complete until the pull request is created.\n\nRemember: You are responsible for ALL code changes in this session. Make sure to:\n- Keep track of all modified files\n- Maintain consistency across changes\n- Handle errors gracefully\n- Verify all changes before completing\n",
    "type": "systemPrompt",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "c8c52a9f-dd5e-43a4-bf7a-ba006bb77173",
    "createdAt": "2025-06-10T06:35:23.310Z",
    "content": "Github issue title: Sync Plan with Github Issue Comment\nGithub issue description: When a Plan is posted as a Github comment, now we have 2 locations where the Plan is saved, both in our neo4j database, and also on Github.\n\nWe should try to have a single source of truth.\n\nSo if a user opts to post the Plan onto a Github Issue as a comment, then we should link that comment id, and let the Github Issue Comment serve as the single source of truth.\n\nThat means on our database, we probably need to create a new Plan version (with linked relationships to the previous Plan version) that suggests now the Plan is hosted in a Github comment, and that any changes to that Github comment should be referred to the Github Comment and not the Plan saved in neo4j.\n\nWe'll have to handle all of the different edge cases, such as:\n1. when a user edits a GitHub comment\n2. When a user deletes the Github comment (while synced). Probably just delete all Plan nodes, and remove :Plan if the node is also a :Message node (we don't want to delete message nodes). This will probably need its own service-level helper function.\n3. If a user decides to un-sync the GitHub comment. Probably create a new Plan node version (connected to previous version), that copies the latest Plan from Github comment.\n\nWe'll also need some UI to let the user sync / un-sync the plan. Perhaps on the `/plan/[planId]` page.\n\nThere should be indications to the user about the status of the Plan in Github comments about its sync status.  Could be text appended at the end the includes metadata about the Plan, such as the Plan Id it's linked to, its sync status (on /off), the commit that the Plan was generated from, etc.\n\nAnd please help me think through anything else here. Any other edge cases, etc.",
    "type": "userMessage",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "a4954a2c-6610-4fa7-a3aa-cfea46b423bf",
    "createdAt": "2025-06-10T06:35:23.381Z",
    "content": "Github issue comments:\n\n- **User**: issuetopr-dev[bot]\n- **Created At**: 6/10/2025, 6:28:18 AM\n- **Reactions**: 0\n- **Comment**: ### Investigation Summary\n\n#### 1. Neo4j Plan Model & Logic (`lib/neo4j/repositories/plan.ts`, `lib/neo4j/services/plan.ts`)\n- **Current Model:**  \n  Plans are labeled in neo4j and linked to issues with an `IMPLEMENTS` relationship.  \n  There is versioning, a `status` field (e.g. \"draft\"), and conversion between db and app plan representations.\n- **No Explicit Sync-to-GitHub Info:**  \n  There is no indication in the Plan model of a \"source of truth\" outside of neo4j or a way to track \"this Plan is now just a pointer to a GitHub comment\".\n\n#### 2. GitHub Issue Comment Posting (`lib/tools/IssueCommentTool.ts`, `components/issues/actions/PostToGitHubButton.tsx`)\n- **PostToGitHubButton:**  \n  Used to manually post Plan content as a GitHub comment. Does not automatically update or sync further, nor does it track comment ID or status.\n- **IssueCommentTool:**  \n  Utility for creating comments on a GitHub issue, wrapping API calls, not directly coupled to Plan state.\n\n#### 3. GitHub Webhook Handling (`app/api/webhook/github/route.ts`)\n- **Routes events (edits, etc) to `routeWebhookHandler`.**\n- **No direct evidence here of handling Plan-specific sync/un-sync logic**  \n  (That would be delegated to the handler).\n\n---\n\n## Issue Analysis\n\n**Classification:**  \nFeature/Improvement — requires a new mechanism for designating source-of-truth and handling plan<->GitHub comment synchronization, with appropriate UI/UX affordances and edge case management.\n\n**Affected Components:**\n- Neo4j Plan Model (`lib/neo4j/repositories/plan.ts`, `lib/neo4j/services/plan.ts`)\n- GitHub Comment Posting and Sync Logic (`PostToGitHubButton.tsx`, API endpoints, possibly Plan UI display)\n- Webhook/Event Handling (`app/api/webhook/github/route.ts` and downstream logic)\n- Plan UI (`app/[username]/[repo]/issues/[issueId]/plan/[planId]/page.tsx`)\n- Types/Schema definitions for Plan, sync status, etc.\n\n---\n\n## Implementation Plan\n\n### 1. **Upgrade the Plan Model in Neo4j**\n- Add fields (in node properties) for:\n  - `sourceOfTruth: 'neo4j' | 'github_comment'`\n  - `githubCommentId` (nullable)\n  - Any sync metadata: `syncStatus`, timestamp, etc.\n- Add migration/util to allow for changing a Plan's source from neo4j → GitHub comment and vice versa (creating a new version node as needed).\n\n### 2. **Sync Logic: Plan → GitHub Comment**\n- When user posts/syncs a Plan to a GitHub comment:\n  - Change (or create new) Plan node with updated `sourceOfTruth: 'github_comment'` and store `githubCommentId`.\n  - Surface the current GitHub comment as canonical in UI.\n\n### 3. **GitHub Comment Edit/Delete Event Handling**\n- On GitHub webhook for comment edit:\n  - If comment is a synced Plan, reflect update (likely fetch new content, update neo4j metadata/version info, if desired).\n- On comment deletion:\n  - On deletion and Plan is still synced, destroy Plan nodes or unlink (convert related Plan node to indicate deletion/archival).\n  - If Plan node also represents a Message node, just remove the `Plan` label, not the node itself (maintain message history).\n- Add service/helper in plan service layer for above logic.\n\n### 4. **Un-sync Logic (GitHub → Neo4j)**\n- If unsync is triggered (user action or recovery):\n  - Create a new Plan node version with `sourceOfTruth: 'neo4j'`, and initialize content from latest GitHub comment.\n  - Ensure links/relations between plan versions are updated.\n\n### 5. **Frontend/UI Enhancements**\n- On `/plan/[planId]` page:\n  - Add clear controls for syncing/un-syncing with GitHub comment.\n  - Show sync status, GitHub comment link, and any associated metadata.\n  - When Plan is synced, warn that edits must happen on GitHub and reflect that in the UI view (\"Plan is synced with GitHub comment X, last updated ...\").\n  - If Plan is not synced, editable as usual.\n- When Plan is rendered as a comment:\n  - Append sync metadata (Plan Id, sync status, commit, etc.) at end.\n\n### 6. **Extra Edge Cases**\n- Handle reverting a Plan to an older Plan version.\n- Multiple plans per issue: ensure sync state is per-Plan, not per-issue.\n- Concurrency: edits on both sides—define rules (likely, GitHub comment is canonical when synced).\n\n---\n\n## Required Code Changes (Outline)\n\n- **Update Neo4j Plan schema, add migration for new fields.**\n- **Plan service/repository:** update to handle sync/unsync/version links.\n- **Webhook handler:** update for GitHub issue comment events (edit/delete); route to Plan sync service as appropriate.\n- **Plan posting logic:** after posting to GH, update Plan node or create new version with sync state.\n- **Un-sync UI/control and API:** allow explicit un-sync action.\n- **UI (`page.tsx` + components):** display Plan sync status, controls; disable or redirect editing for GitHub-synced Plans.\n\n---\n\n## Next Steps\n\n1. Examine type definitions for Plan (likely in `lib/types/plan.ts`) to see how to best extend `Plan`.\n2. Inspect the UI entry point for the Plan view/edit (`app/[username]/[repo]/issues/[issueId]/plan/[planId]/page.tsx`) for where to add sync controls and display logic.\n3. Search for `routeWebhookHandler` to determine where GitHub webhook payloads are actually processed for comments, so we can pinpoint where to inject Plan sync logic.\n\nWould you like me to proceed with this targeted file reading and code search?\n",
    "type": "userMessage",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "3cec98b8-723c-43bb-9372-746cdf3e2b56",
    "createdAt": "2025-06-10T06:35:23.453Z",
    "content": "Here is the codebase's tree directory:\nREADME.md\n__tests__/api/stream/ping.test.ts\n__tests__/components/PingStream.test.tsx\n__tests__/lib/tools/GetFileContent.test.ts\n__tests__/lib/tools/SyncBranchTool.test.ts\napp/[username]/[repo]/issues/[issueId]/page.tsx\napp/[username]/[repo]/issues/[issueId]/plan/[planId]/not-found.tsx\napp/[username]/[repo]/issues/[issueId]/plan/[planId]/page.tsx\napp/[username]/[repo]/issues/page.tsx\napp/[username]/[repo]/pullRequests/page.tsx\napp/[username]/page.tsx\napp/api/analyze-pr/route.ts\napp/api/auth/[...nextauth]/route.ts\napp/api/comment/route.ts\napp/api/github/fetch/route.ts\napp/api/health/neo4j/route.ts\napp/api/issues/[issueId]/comments/route.ts\napp/api/openai/check/route.ts\napp/api/resolve/route.ts\napp/api/review/route.ts\napp/api/sse/route.ts\napp/api/stream/ping/route.ts\napp/api/test/route.ts\napp/api/webhook/github/route.ts\napp/api/workflow/[workflowId]/route.ts\napp/api/workflow/alignment-check/route.ts\napp/blogs/[slug]/page.tsx\napp/blogs/page.tsx\napp/contribute/page.tsx\napp/demo/page.tsx\napp/favicon.ico\napp/globals.css\napp/issue-search/page.tsx\napp/issues/page.tsx\napp/layout.tsx\napp/page.tsx\napp/redirect/page.tsx\napp/settings/page.tsx\napp/styles/custom.css\napp/workflow-runs/[traceId]/page.tsx\napp/workflow-runs/page.tsx\nauth.ts\nblogs/whyIssueToPR.md\ncomponents/PingStream.tsx\ncomponents/RepositoryList.tsx\ncomponents/StreamHandler.tsx\ncomponents/TestButton.tsx\ncomponents/blog/MarkdownRenderer.tsx\ncomponents/common/DataTable.tsx\ncomponents/common/FeedbackButton.tsx\ncomponents/common/RepoSelector.tsx\ncomponents/contribute/GitHubItemDetails.tsx\ncomponents/github/BaseGitHubItemCard.tsx\ncomponents/issues/IssueActions.tsx\ncomponents/issues/IssueDetailsWrapper.tsx\ncomponents/issues/IssuePlans.tsx\ncomponents/issues/IssueRow.tsx\ncomponents/issues/IssueTable.tsx\ncomponents/issues/IssueWorkflowRuns.tsx\ncomponents/issues/NewTaskInput.tsx\ncomponents/issues/StatusIndicators.tsx\ncomponents/issues/actions/PostToGitHubButton.tsx\ncomponents/issues/controllers/CreatePRController.tsx\ncomponents/issues/controllers/GenerateResolutionPlanController.tsx\ncomponents/issues/issue-explorer.tsx\ncomponents/issues/issue-search.tsx\ncomponents/landing-page/ComparisonToIDEAgents.tsx\ncomponents/landing-page/ContributePublic.tsx\ncomponents/landing-page/Details.tsx\ncomponents/landing-page/Features.tsx\ncomponents/landing-page/Footer.tsx\ncomponents/landing-page/GetStarted.tsx\ncomponents/landing-page/Hero.tsx\ncomponents/landing-page/Pricing.tsx\ncomponents/landing-page/Steps.tsx\ncomponents/layout/Breadcrumb.tsx\ncomponents/layout/DynamicNavigation.tsx\ncomponents/layout/Navigation.tsx\ncomponents/layout/TableSkeleton.tsx\ncomponents/providers/SessionProvider.tsx\ncomponents/pull-requests/PRActions.tsx\ncomponents/pull-requests/PullRequestRow.tsx\ncomponents/pull-requests/PullRequestTable.tsx\ncomponents/pull-requests/controllers/AlignmentCheckController.tsx\ncomponents/pull-requests/controllers/AnalyzePRController.tsx\ncomponents/pull-requests/controllers/IdentifyPRGoalController.tsx\ncomponents/pull-requests/controllers/ReviewPRController.tsx\ncomponents/settings/APIKeyInput.tsx\ncomponents/ui/accordion.tsx\ncomponents/ui/badge.tsx\ncomponents/ui/breadcrumb.tsx\ncomponents/ui/button.tsx\ncomponents/ui/calendar.tsx\ncomponents/ui/card.tsx\ncomponents/ui/checkbox.tsx\ncomponents/ui/collapsible-content.tsx\ncomponents/ui/collapsible.tsx\ncomponents/ui/dropdown-menu.tsx\ncomponents/ui/form.tsx\ncomponents/ui/grid-background.tsx\ncomponents/ui/hover-card.tsx\ncomponents/ui/input.tsx\ncomponents/ui/label.tsx\ncomponents/ui/moving-border-card.tsx\ncomponents/ui/nav-button.tsx\ncomponents/ui/navigation-menu.tsx\ncomponents/ui/pagination.tsx\ncomponents/ui/popover.tsx\ncomponents/ui/scroll-area.tsx\ncomponents/ui/select.tsx\ncomponents/ui/sheet.tsx\ncomponents/ui/shine-button.tsx\ncomponents/ui/switch.tsx\ncomponents/ui/table.tsx\ncomponents/ui/tabs.tsx\ncomponents/ui/text-lg.tsx\ncomponents/ui/text-md.tsx\ncomponents/ui/text-sm.tsx\ncomponents/ui/textarea.tsx\ncomponents/ui/toast.tsx\ncomponents/ui/toaster.tsx\ncomponents/ui/tooltip.tsx\ncomponents/workflow-runs/events/CopyMarkdownButton.tsx\ncomponents/workflow-runs/events/ErrorEvent.tsx\ncomponents/workflow-runs/events/EventTime.tsx\ncomponents/workflow-runs/events/LLMResponseEvent.tsx\ncomponents/workflow-runs/events/StatusUpdate.tsx\ncomponents/workflow-runs/events/SystemPromptEvent.tsx\ncomponents/workflow-runs/events/ToolCallEvent.tsx\ncomponents/workflow-runs/events/ToolCallResultEvent.tsx\ncomponents/workflow-runs/events/UserMessageEvent.tsx\ncomponents/workflow-runs/events/index.ts\ncomponents.json\ndocker/README.md\ndocker/compose/neo4j-staging.yml\ndocker/compose/neo4j.yml\ndocker/docker-compose.yml\ndocs/README.md\ndocs/REORGANIZATION.md\ndocs/assets/data-flow-diagram.md\ndocs/code-structure.md\ndocs/guides/ai-integration.md\ndocs/guides/architecture.md\ndocs/guides/authentication.md\ndocs/guides/databases/data-flow.md\ndocs/guides/databases/neo4j-architecture.md\ndocs/guides/databases/postgresql-architecture.md\ndocs/guides/databases/redis-architecture.md\ndocs/guides/observability.md\ndocs/guides/streaming-architecture.md\ndocs/internal/README.md\ndocs/setup/getting-started.md\ninternal-docs/general-to-do.md\ninternal-docs/issue-to-pr/user-stories.md\ninternal-docs/run-workflow/plan.md\ninternal-docs/run-workflow/ui-flow.md\ninternal-docs/run-workflow/user-stories.md\ninternal-docs/templates/prd-template.md\ninternal-docs/workflow-visualization/plan.md\ninternal-docs/workflow-visualization/prd.md\ninternal-docs/workflow-visualization/user-stories.md\njest.config.ts\nlib/actions/auth.ts\nlib/agents/GoalIdentifierAgent.ts\nlib/agents/PostAlignmentAssessmentAgent.ts\nlib/agents/alignmentAgent.ts\nlib/agents/base/index.ts\nlib/agents/coder.ts\nlib/agents/coordinator.ts\nlib/agents/index.ts\nlib/agents/reviewer.ts\nlib/agents/thinker.ts\nlib/auth/config.ts\nlib/fs.ts\nlib/git.ts\nlib/github/content.ts\nlib/github/git.ts\nlib/github/index.ts\nlib/github/issues.ts\nlib/github/pullRequests.ts\nlib/github/search.ts\nlib/github/users.ts\nlib/globals.ts\nlib/hooks/use-media-query.ts\nlib/hooks/use-toast.ts\nlib/langfuse.ts\nlib/neo4j/client.ts\nlib/neo4j/repositories/event.ts\nlib/neo4j/repositories/issue.ts\nlib/neo4j/repositories/plan.ts\nlib/neo4j/repositories/workflowRun.ts\nlib/neo4j/services/event.ts\nlib/neo4j/services/plan.ts\nlib/neo4j/services/workflow.ts\nlib/openai.ts\nlib/patch.ts\nlib/redis-old.ts\nlib/redis.ts\nlib/schemas/api.ts\nlib/services/EventEmitter.ts\nlib/services/redis-stream.ts\nlib/tools/ApplyPatchTool.ts\nlib/tools/Branch.ts\nlib/tools/Commit.ts\nlib/tools/CreatePRTool.ts\nlib/tools/GetFileContent.ts\nlib/tools/GetIssueTool.ts\nlib/tools/IssueCommentTool.ts\nlib/tools/RipgrepSearchTool.ts\nlib/tools/SyncBranchTool.ts\nlib/tools/WriteFileContent.ts\nlib/tools/helper.ts\nlib/tools/index.ts\nlib/types/README.md\nlib/types/api/schemas.ts\nlib/types/db/neo4j.ts\nlib/types/db/postgres.ts\nlib/types/events.ts\nlib/types/github.ts\nlib/types/index.ts\nlib/types/neo4j.ts\nlib/types/plan.ts\nlib/types/schemas.ts\nlib/types/workflow.ts\nlib/utils/auth-utils.ts\nlib/utils/utils-common.ts\nlib/utils/utils-server.ts\nlib/webhook.ts\nlib/workflows/alignmentCheck.ts\nlib/workflows/commentOnIssue.ts\nlib/workflows/identifyPRGoal.ts\nlib/workflows/index.ts\nlib/workflows/resolveIssue.ts\nlib/workflows/reviewPullRequest.ts\nmiddleware.ts\nnext.config.js\npackage.json\npnpm-lock.yaml\npostcss.config.mjs\npublic/diagram.svg\npublic/file.svg\npublic/fonts/GeistMonoVF.woff\npublic/fonts/GeistVF.woff\npublic/globe.svg\npublic/images/contribute-public.png\npublic/mockServiceWorker.js\npublic/next.svg\npublic/vercel.svg\npublic/window.svg\nscripts/migrations/README.md\nscripts/migrations/backup-neo4j.sh\nscripts/migrations/restore-neo4j.sh\nscripts/migrations/workflow-to-workflowrun.md\nscripts/start-services.sh\ntailwind.config.ts\ntest-utils/index.tsx\ntest-utils/jest.setup.ts\ntest-utils/mocks/handlers.ts\ntest-utils/mocks/server.ts\ntsconfig.json",
    "type": "userMessage",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "f9cb5172-44fb-42fc-a069-48e594a1eee1",
    "createdAt": "2025-06-10T06:35:23.529Z",
    "content": "\nImplementation plan for this issue (from previous workflow):\n### Investigation Summary\n\n#### 1. Neo4j Plan Model & Logic (`lib/neo4j/repositories/plan.ts`, `lib/neo4j/services/plan.ts`)\n- **Current Model:**  \n  Plans are labeled in neo4j and linked to issues with an `IMPLEMENTS` relationship.  \n  There is versioning, a `status` field (e.g. \"draft\"), and conversion between db and app plan representations.\n- **No Explicit Sync-to-GitHub Info:**  \n  There is no indication in the Plan model of a \"source of truth\" outside of neo4j or a way to track \"this Plan is now just a pointer to a GitHub comment\".\n\n#### 2. GitHub Issue Comment Posting (`lib/tools/IssueCommentTool.ts`, `components/issues/actions/PostToGitHubButton.tsx`)\n- **PostToGitHubButton:**  \n  Used to manually post Plan content as a GitHub comment. Does not automatically update or sync further, nor does it track comment ID or status.\n- **IssueCommentTool:**  \n  Utility for creating comments on a GitHub issue, wrapping API calls, not directly coupled to Plan state.\n\n#### 3. GitHub Webhook Handling (`app/api/webhook/github/route.ts`)\n- **Routes events (edits, etc) to `routeWebhookHandler`.**\n- **No direct evidence here of handling Plan-specific sync/un-sync logic**  \n  (That would be delegated to the handler).\n\n---\n\n## Issue Analysis\n\n**Classification:**  \nFeature/Improvement — requires a new mechanism for designating source-of-truth and handling plan<->GitHub comment synchronization, with appropriate UI/UX affordances and edge case management.\n\n**Affected Components:**\n- Neo4j Plan Model (`lib/neo4j/repositories/plan.ts`, `lib/neo4j/services/plan.ts`)\n- GitHub Comment Posting and Sync Logic (`PostToGitHubButton.tsx`, API endpoints, possibly Plan UI display)\n- Webhook/Event Handling (`app/api/webhook/github/route.ts` and downstream logic)\n- Plan UI (`app/[username]/[repo]/issues/[issueId]/plan/[planId]/page.tsx`)\n- Types/Schema definitions for Plan, sync status, etc.\n\n---\n\n## Implementation Plan\n\n### 1. **Upgrade the Plan Model in Neo4j**\n- Add fields (in node properties) for:\n  - `sourceOfTruth: 'neo4j' | 'github_comment'`\n  - `githubCommentId` (nullable)\n  - Any sync metadata: `syncStatus`, timestamp, etc.\n- Add migration/util to allow for changing a Plan's source from neo4j → GitHub comment and vice versa (creating a new version node as needed).\n\n### 2. **Sync Logic: Plan → GitHub Comment**\n- When user posts/syncs a Plan to a GitHub comment:\n  - Change (or create new) Plan node with updated `sourceOfTruth: 'github_comment'` and store `githubCommentId`.\n  - Surface the current GitHub comment as canonical in UI.\n\n### 3. **GitHub Comment Edit/Delete Event Handling**\n- On GitHub webhook for comment edit:\n  - If comment is a synced Plan, reflect update (likely fetch new content, update neo4j metadata/version info, if desired).\n- On comment deletion:\n  - On deletion and Plan is still synced, destroy Plan nodes or unlink (convert related Plan node to indicate deletion/archival).\n  - If Plan node also represents a Message node, just remove the `Plan` label, not the node itself (maintain message history).\n- Add service/helper in plan service layer for above logic.\n\n### 4. **Un-sync Logic (GitHub → Neo4j)**\n- If unsync is triggered (user action or recovery):\n  - Create a new Plan node version with `sourceOfTruth: 'neo4j'`, and initialize content from latest GitHub comment.\n  - Ensure links/relations between plan versions are updated.\n\n### 5. **Frontend/UI Enhancements**\n- On `/plan/[planId]` page:\n  - Add clear controls for syncing/un-syncing with GitHub comment.\n  - Show sync status, GitHub comment link, and any associated metadata.\n  - When Plan is synced, warn that edits must happen on GitHub and reflect that in the UI view (\"Plan is synced with GitHub comment X, last updated ...\").\n  - If Plan is not synced, editable as usual.\n- When Plan is rendered as a comment:\n  - Append sync metadata (Plan Id, sync status, commit, etc.) at end.\n\n### 6. **Extra Edge Cases**\n- Handle reverting a Plan to an older Plan version.\n- Multiple plans per issue: ensure sync state is per-Plan, not per-issue.\n- Concurrency: edits on both sides—define rules (likely, GitHub comment is canonical when synced).\n\n---\n\n## Required Code Changes (Outline)\n\n- **Update Neo4j Plan schema, add migration for new fields.**\n- **Plan service/repository:** update to handle sync/unsync/version links.\n- **Webhook handler:** update for GitHub issue comment events (edit/delete); route to Plan sync service as appropriate.\n- **Plan posting logic:** after posting to GH, update Plan node or create new version with sync state.\n- **Un-sync UI/control and API:** allow explicit un-sync action.\n- **UI (`page.tsx` + components):** display Plan sync status, controls; disable or redirect editing for GitHub-synced Plans.\n\n---\n\n## Next Steps\n\n1. Examine type definitions for Plan (likely in `lib/types/plan.ts`) to see how to best extend `Plan`.\n2. Inspect the UI entry point for the Plan view/edit (`app/[username]/[repo]/issues/[issueId]/plan/[planId]/page.tsx`) for where to add sync controls and display logic.\n3. Search for `routeWebhookHandler` to determine where GitHub webhook payloads are actually processed for comments, so we can pinpoint where to inject Plan sync logic.\n\nWould you like me to proceed with this targeted file reading and code search?\n",
    "type": "userMessage",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "d419a029-7404-4347-ac53-85f6c67d1837",
    "createdAt": "2025-06-10T06:35:25.888Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_sc1WyywBPg9kYR9YSfbdjwkW",
    "args": "{\"relativePath\": \"lib/types/plan.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "f02443d1-8cfd-4424-bea4-f50cdacf2420",
    "createdAt": "2025-06-10T06:35:25.919Z",
    "content": "import { Integer, Node } from \"neo4j-driver\"\n\n/**\n * @deprecated This type is deprecated. Use types from the neo4j.ts file instead.\n */\nexport interface PlanProperties {\n  id: string\n  status: \"draft\" | \"approved\" | \"rejected\"\n  type: string\n  createdAt: Date\n}\n\n/**\n * @deprecated This type is deprecated. Use types from the neo4j.ts file instead.\n */\nexport type Plan = Node<Integer, PlanProperties>\n",
    "type": "toolCallResult",
    "toolCallId": "call_sc1WyywBPg9kYR9YSfbdjwkW",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "b14c77be-abe8-4ed8-a039-69883ac9b6e8",
    "createdAt": "2025-06-10T06:35:25.942Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_IY3E1CXJyGQH0Cp7xW6G4Tgh",
    "args": "{\"relativePath\": \"app/[username]/[repo]/issues/[issueId]/plan/[planId]/page.tsx\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "7fa53bb3-7911-4ecd-be12-7fa41f7651f7",
    "createdAt": "2025-06-10T06:35:25.968Z",
    "content": "import Link from \"next/link\"\nimport { notFound } from \"next/navigation\"\nimport ReactMarkdown from \"react-markdown\"\n\nimport {\n  Card,\n  CardContent,\n  CardDescription,\n  CardHeader,\n  CardTitle,\n} from \"@/components/ui/card\"\nimport { getPlanWithDetails } from \"@/lib/neo4j/services/plan\"\n\ninterface PageProps {\n  params: {\n    planId: string\n    issueId: string\n  }\n}\n\nexport default async function PlanPage({ params }: PageProps) {\n  const { planId } = params\n  const { plan, workflow, issue } = await getPlanWithDetails(planId)\n\n  if (!plan) {\n    notFound()\n  }\n\n  return (\n    <div className=\"flex min-h-screen items-start justify-center py-8 px-4\">\n      <Card className=\"w-full max-w-4xl\">\n        <CardHeader>\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <CardTitle>Plan Details</CardTitle>\n              <CardDescription>\n                Created on {plan.createdAt.toLocaleDateString()}\n              </CardDescription>\n            </div>\n          </div>\n        </CardHeader>\n        <CardContent className=\"space-y-6\">\n          <div>\n            <h3 className=\"text-lg font-semibold mb-2\">Plan Content</h3>\n            <div className=\"prose prose-sm dark:prose-invert max-w-none rounded-lg bg-muted p-4\">\n              <ReactMarkdown>{plan.content}</ReactMarkdown>\n            </div>\n          </div>\n\n          {issue && (\n            <div>\n              <h3 className=\"text-lg font-semibold mb-2\">Related Issue</h3>\n              <Link\n                href={`/${issue.repoFullName}/issues/${issue.number}`}\n                className=\"text-primary hover:underline\"\n              >\n                #{issue.number}\n              </Link>\n            </div>\n          )}\n\n          {workflow && (\n            <div>\n              <h3 className=\"text-lg font-semibold mb-2\">\n                Workflow Information\n              </h3>\n              <div>\n                <p>\n                  <strong>Type:</strong> {workflow.type}\n                </p>\n                <p>\n                  <strong>ID:</strong> {workflow.id}\n                </p>\n              </div>\n            </div>\n          )}\n\n          <div>\n            <h3 className=\"text-lg font-semibold mb-2\">Metadata</h3>\n            <div className=\"grid grid-cols-2 gap-4\">\n              <div>\n                <p>\n                  <strong>Status:</strong> {plan.status}\n                </p>\n              </div>\n              <div>\n                <p>\n                  <strong>Plan ID:</strong> {plan.id}\n                </p>\n                <p>\n                  <strong>Version:</strong> {plan.version}\n                </p>\n              </div>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n    </div>\n  )\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_IY3E1CXJyGQH0Cp7xW6G4Tgh",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "afbf2583-f5cc-4fe6-aa85-6c538382891b",
    "createdAt": "2025-06-10T06:35:26.032Z",
    "type": "toolCall",
    "toolName": "ripgrep_search",
    "toolCallId": "call_eRdkc0eB4cQZSY8aXXNmdriq",
    "args": "{\"query\": \"routeWebhookHandler\", \"ignoreCase\": true, \"hidden\": false, \"follow\": false}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "55d8e1db-c23a-48e3-b3e5-9bde00c4e005",
    "createdAt": "2025-06-10T06:35:26.068Z",
    "content": "./app/api/webhook/github/route.ts\n2-import { NextRequest } from \"next/server\"\n3-\n4-import { runWithInstallationId } from \"@/lib/utils/utils-server\"\n5:import { routeWebhookHandler } from \"@/lib/webhook\"\n6-\n7-async function verifySignature(\n8-  signature: string,\n--\n41-\n42-    // Route the payload to the appropriate handler\n43-    runWithInstallationId(installationId, async () => {\n44:      await routeWebhookHandler({\n45-        event,\n46-        payload,\n47-      })\n\n./lib/webhook.ts\n23-  Repository = \"repository\",\n24-}\n25-\n26:export const routeWebhookHandler = async ({\n27-  event,\n28-  payload,\n29-}: {\n",
    "type": "toolCallResult",
    "toolCallId": "call_eRdkc0eB4cQZSY8aXXNmdriq",
    "toolName": "ripgrep_search",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "0b98beed-b808-4345-8f43-d2ba1cd0c146",
    "createdAt": "2025-06-10T06:35:29.266Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_b8GWUZO1jLn6nDUKzyc4zq0s",
    "args": "{\"relativePath\": \"lib/types/neo4j.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "63189801-8a58-40d0-b016-0c449f40606b",
    "createdAt": "2025-06-10T06:35:29.338Z",
    "content": "import { LLMResponse as LLMResponseNew } from \"@/lib/types\"\n\n// Core Entity Types\n// TODO: Use zod to create schemas, then export types from schemas\n// TODO: Define baseline application-level schemas, then extend database schemas from there\n// TODO: move this file to /types/db/neo4j.ts\n\nexport type User = {\n  id: string // Maps to PostgreSQL users.id\n  displayName: string // Cached display name for convenient querying\n}\n\n/**\n * @deprecated Use the Zod schema and inferred type from lib/types/index.ts instead.\n */\nexport type Repository = {\n  name: string // Repository name\n  owner: string // Repository owner\n  id: string // GitHub repository ID\n  // Mutable properties from GitHub API - not stored in Neo4j\n  description?: string\n  defaultBranch?: string\n  settings?: Record<string, unknown>\n  visibility?: \"public\" | \"private\"\n}\n\n/**\n * @deprecated Use the Zod schema and inferred type from lib/types/index.ts instead.\n */\nexport type Issue = {\n  number: number // Issue number\n  id: string // GitHub issue ID\n  createdAt: Date // Creation timestamp\n  repoFullName: string // Repository name\n  // Mutable properties from GitHub API - not stored in Neo4j\n  title?: string\n  body?: string\n  state?: \"open\" | \"closed\"\n  labels?: string[]\n  assignees?: string[]\n  updatedAt?: Date\n}\n\n/**\n * @deprecated Use the Zod schema and inferred type from lib/types/index.ts instead.\n */\nexport type PullRequest = {\n  number: number // PR number\n  id: string // GitHub PR ID\n  createdAt: Date // Creation timestamp\n  // Mutable properties from GitHub API - not stored in Neo4j\n  title?: string\n  body?: string\n  state?: \"open\" | \"closed\" | \"merged\"\n  branch?: string\n  reviewers?: string[]\n  labels?: string[]\n  mergeable?: boolean\n  updatedAt?: Date\n}\n\n// Workflow Management Types\n\nexport type WorkflowType =\n  | \"commentOnIssue\"\n  | \"resolveIssue\"\n  | \"identifyPRGoal\"\n  | \"reviewPullRequest\"\n\nexport type WorkflowRun = {\n  id: string\n  workflowType: WorkflowType\n  created_at: Date // TODO: Change to `createdAt`\n  // status - need this for application level, but not stored in Neo4j\n}\n\n// Event Types\n\n// Define the possible event types\ntype EventType =\n  | \"status\"\n  | \"message\"\n  | \"toolCall\"\n  | \"toolCallResult\"\n  | \"workflowState\"\n  | \"reviewComment\"\n  | \"systemPrompt\"\n  | \"userMessage\"\n  | \"llmResponse\"\n  | \"error\"\n\n// Base Event properties for all events\n/**\n * @deprecated Use the Zod schema and inferred type from lib/types/index.ts instead.\n */\nexport interface BaseEvent {\n  id: string\n  createdAt: Date\n  workflowId: string\n  content?: string\n  type: EventType\n}\n\n// Basic Event\n/**\n * @deprecated Use the Zod schema and inferred type from lib/types/index.ts instead.\n */\nexport interface StatusEvent extends BaseEvent {\n  type: \"status\"\n}\n\n// Message Events\n/**\n * @deprecated Use the Zod schema and inferred type from lib/types/index.ts instead.\n */\nexport interface SystemPrompt extends BaseEvent {\n  type: \"systemPrompt\"\n  content: string\n}\n\n/**\n * @deprecated Use the Zod schema and inferred type from lib/types/index.ts instead.\n */\nexport interface UserMessage extends BaseEvent {\n  type: \"userMessage\"\n  content: string\n}\n\n/**\n * @deprecated Use the Zod schema and inferred type from lib/types/index.ts instead.\n */\nexport interface LLMResponse extends BaseEvent {\n  type: \"llmResponse\"\n  content: string\n}\n\n// Tool Events\n/**\n * @deprecated Use the Zod schema and inferred type from lib/types/index.ts instead.\n */\nexport interface ToolCall extends BaseEvent {\n  type: \"toolCall\"\n  toolName: string\n  toolCallId: string\n  arguments: string\n}\n\n/**\n * @deprecated Use the Zod schema and inferred type from lib/types/index.ts instead.\n */\nexport interface ToolCallResult extends BaseEvent {\n  type: \"toolCallResult\"\n  toolCallId: string\n  toolName: string\n  content: string\n}\n\n// Workflow State Events\n/**\n * @deprecated Use the Zod schema and inferred type from lib/types/index.ts instead.\n */\nexport type WorkflowRunState = \"running\" | \"completed\" | \"error\"\n/**\n * @deprecated Use the Zod schema and inferred type from lib/types/index.ts instead.\n */\nexport interface WorkflowState extends BaseEvent {\n  type: \"workflowState\"\n  state: WorkflowRunState\n}\n\n// Review Events\n/**\n * @deprecated Use the Zod schema and inferred type from lib/types/index.ts instead.\n */\nexport interface ReviewComment extends BaseEvent {\n  type: \"reviewComment\"\n  content: string\n  planId: string\n}\n\n/**\n * @deprecated Use the Zod schema and inferred type from lib/types/index.ts instead.\n */\nexport interface ErrorEvent extends BaseEvent {\n  type: \"error\"\n  content: string\n}\n\n// Plan\n/**\n * @deprecated Use index.ts instead\n */\nexport type PlanStatus =\n  | \"pendingReview\"\n  | \"approved\"\n  | \"rejected\"\n  | \"implemented\"\n\n/**\n * @deprecated Use index.ts instead\n */\nexport type Plan = {\n  id: string\n  content: string\n  status: PlanStatus\n  version: number\n  editedAt?: Date\n  editMessage?: string\n}\n\n// Union type for all event types\nexport type AnyEvent =\n  | StatusEvent\n  | SystemPrompt\n  | UserMessage\n  | ToolCall\n  | ToolCallResult\n  | WorkflowState\n  | ReviewComment\n  | ErrorEvent\n  | LLMResponseNew\n\n// Relationship Types\n\nexport type RelationshipTypes =\n  // Repository Relationships\n  | \"HAS_ISSUES\"\n  | \"HAS_PRS\"\n  | \"OWNED_BY\"\n  // Issue Relationships\n  | \"BELONGS_TO\"\n  | \"CREATED_BY\"\n  // Workflow run Relationships\n  | \"STARTS_WITH\" // Links WorkflowRun to its first event\n  | \"BASED_ON_ISSUE\" // Links WorkflowRun to its Issue\n  | \"LAUNCHED_BY\" // Links WorkflowRun to the User that launched it\n  // PullRequest Relationships\n  | \"RESOLVES\"\n  | \"OPENED_BY\"\n  // Event Relationships\n  | \"NEXT\" // Links events in chronological order\n  | \"REFERENCES\" // Event referencing another node (Issue, PR, etc)\n  | \"COMMENTS_ON\" // Review comments on plans\n  // User Relationships\n  | \"OWNED_BY\"\n  | \"DRAFTED_BY\"\n  | \"POSTED\"\n  | \"CREATED_BY\"\n  | \"LAUNCHED_BY\"\n  // Plan Relationships\n  | \"NEXT_VERSION\"\n  | \"IMPLEMENTS\"\n  | \"DRAFTED_BY\"\n\nexport type Relationship = {\n  type: RelationshipTypes\n  from: string // Node ID\n  to: string // Node ID\n  properties?: Record<string, unknown>\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_b8GWUZO1jLn6nDUKzyc4zq0s",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "9d12712b-d497-4e2a-8c4d-573679dfce41",
    "createdAt": "2025-06-10T06:35:29.406Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_RDy9By0x0LJuIsCUqvHZnlue",
    "args": "{\"relativePath\": \"lib/neo4j/repositories/plan.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "4227695f-933e-464f-97dd-dab46078f96d",
    "createdAt": "2025-06-10T06:35:29.430Z",
    "content": "import { int, Integer, ManagedTransaction, Node } from \"neo4j-driver\"\nimport { z } from \"zod\"\n\nimport { Plan as AppPlan } from \"@/lib/types\"\nimport {\n  Issue,\n  issueSchema,\n  LLMResponseWithPlan,\n  llmResponseWithPlanSchema,\n  Plan,\n  planSchema,\n  WorkflowRun,\n  workflowRunSchema,\n} from \"@/lib/types/db/neo4j\"\n\n// Retrieve Event node by id\nexport async function getEventById(\n  tx: ManagedTransaction,\n  { eventId }: { eventId: string }\n) {\n  //TODO: Implement this\n}\n\nexport async function listPlansForIssue(\n  tx: ManagedTransaction,\n  { repoFullName, issueNumber }: { repoFullName: string; issueNumber: number }\n) {\n  const result = await tx.run<{\n    p: Node<Integer, Plan | LLMResponseWithPlan, \"Plan\">\n  }>(\n    `\n    MATCH (p:Plan)-[:IMPLEMENTS]->(i:Issue {number: $issueNumber, repoFullName: $repoFullName})\n    RETURN p\n    `,\n    { repoFullName, issueNumber }\n  )\n\n  return result.records.map((record) => {\n    const raw = record.get(\"p\")?.properties\n    return z.union([planSchema, llmResponseWithPlanSchema]).parse(raw)\n  })\n}\n\n// Add :Plan label and properties to Event node\nexport async function labelEventAsPlan(\n  tx: ManagedTransaction,\n  {\n    eventId,\n    status = \"draft\",\n    version = int(1),\n  }: { eventId: string; status?: string; version?: Integer }\n): Promise<LLMResponseWithPlan> {\n  const result = await tx.run<{\n    e: Node<Integer, LLMResponseWithPlan, \"Event | Plan\">\n  }>(\n    `MATCH (e:Event {id: $eventId})\n     SET e:Plan\n     SET e.status = $status\n     SET e.version = $version\n     RETURN e`,\n    { eventId, status, version }\n  )\n\n  const raw = result.records[0]?.get(\"e\")?.properties\n  return llmResponseWithPlanSchema.parse(raw)\n}\n\n// Create :IMPLEMENTS relationship from Plan to Issue\nexport async function createPlanImplementsIssue(\n  tx: ManagedTransaction,\n  {\n    eventId,\n    issueNumber,\n    repoFullName,\n  }: { eventId: string; issueNumber: Integer; repoFullName: string }\n): Promise<{ plan: Plan | LLMResponseWithPlan; issue: Issue }> {\n  const result = await tx.run<{\n    p: Node<Integer, Plan | LLMResponseWithPlan, \"Plan\">\n    i: Node<Integer, Issue, \"Issue\">\n  }>(\n    `MATCH (p:Plan {id: $eventId})\n    OPTIONAL MATCH(i:Issue {number: $issueNumber, repoFullName: $repoFullName})\n     CREATE (p)-[:IMPLEMENTS]->(i)\n     RETURN p, i`,\n    { eventId, issueNumber, repoFullName }\n  )\n  const p = result.records[0]?.get(\"p\")?.properties\n  const i = result.records[0]?.get(\"i\")?.properties\n\n  return {\n    plan: z.union([planSchema, llmResponseWithPlanSchema]).parse(p),\n    issue: issueSchema.parse(i),\n  }\n}\n\n// Convert db-level Plan to app-level Plan (currently passthrough, but for future-proofing)\nexport const toAppPlan = (dbPlan: Plan): AppPlan => {\n  return {\n    ...dbPlan,\n    version: dbPlan.version.toNumber(),\n    createdAt: dbPlan.createdAt.toStandardDate(),\n  }\n}\n\n// Get Plan and related nodes by planId\nexport async function getPlanWithDetails(\n  tx: ManagedTransaction,\n  { planId }: { planId: string }\n) {\n  const result = await tx.run<{\n    p: Node<Integer, Plan | LLMResponseWithPlan, \"Plan\">\n    w: Node<Integer, WorkflowRun, \"WorkflowRun\">\n    i: Node<Integer, Issue, \"Issue\">\n  }>(\n    `\n    MATCH (p:Plan {id: $planId})-[:IMPLEMENTS]->(i:Issue)<-[:BASED_ON_ISSUE]-(w:WorkflowRun)\n    RETURN p, w, i\n    `,\n    { planId }\n  )\n\n  const raw = result.records[0]\n\n  return {\n    plan: planSchema.parse(raw.get(\"p\")?.properties),\n    workflow: workflowRunSchema.parse(raw.get(\"w\")?.properties),\n    issue: issueSchema.parse(raw.get(\"i\")?.properties),\n  }\n}\n\n// Batch plan status for multiple issues\nexport async function listPlanStatusForIssues(\n  tx: ManagedTransaction,\n  {\n    repoFullName,\n    issueNumbers,\n  }: { repoFullName: string; issueNumbers: number[] }\n): Promise<Record<number, boolean>> {\n  if (!issueNumbers.length) return {}\n  const cypher = `\n    MATCH (i:Issue)\n    WHERE i.repoFullName = $repoFullName AND i.number IN $issueNumbers\n    OPTIONAL MATCH (p:Plan)-[:IMPLEMENTS]->(i)\n    RETURN i.number AS number, count(p) > 0 AS hasPlan\n  `\n  const result = await tx.run(cypher, { repoFullName, issueNumbers })\n  const status: Record<number, boolean> = {}\n  for (const record of result.records) {\n    status[record.get(\"number\")] = record.get(\"hasPlan\")\n  }\n  return status\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_RDy9By0x0LJuIsCUqvHZnlue",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "6652c3cc-e9e8-4604-beac-2bb0a7032961",
    "createdAt": "2025-06-10T06:35:29.503Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_p7TLlMFbeD1EY7xGwnsGH8hL",
    "args": "{\"relativePath\": \"lib/neo4j/services/plan.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "3ffaa917-f71b-419d-8525-75263ec4cf5f",
    "createdAt": "2025-06-10T06:35:29.530Z",
    "content": "import { int, ManagedTransaction } from \"neo4j-driver\"\n\nimport { n4j } from \"@/lib/neo4j/client\"\nimport { toAppIssue } from \"@/lib/neo4j/repositories/issue\"\nimport {\n  createPlanImplementsIssue,\n  getPlanWithDetails as dbGetPlanWithDetails,\n  labelEventAsPlan,\n  listPlansForIssue as dbListPlansForIssue,\n  listPlanStatusForIssues as dbListPlanStatusForIssues,\n  toAppPlan,\n} from \"@/lib/neo4j/repositories/plan\"\nimport { toAppWorkflowRun } from \"@/lib/neo4j/repositories/workflowRun\"\nimport { Issue, LLMResponseWithPlan, Plan, WorkflowRun } from \"@/lib/types\"\n\nexport async function listPlansForIssue({\n  repoFullName,\n  issueNumber,\n}: {\n  repoFullName: string\n  issueNumber: number\n}) {\n  const session = await n4j.getSession()\n\n  try {\n    const result = await session.executeRead(async (tx: ManagedTransaction) => {\n      return await dbListPlansForIssue(tx, {\n        repoFullName,\n        issueNumber,\n      })\n    })\n    return result.map(toAppPlan)\n  } finally {\n    await session.close()\n  }\n}\n\n/**\n * Finds an existing event by eventId and labels it as a Plan, attaching default plan metadata (status, version, etc).\n * Then, links the labeled e:Event:Plan node to the underlying Issue node in the graph.\n */\nexport async function tagMessageAsPlan({\n  eventId,\n  workflowId,\n  issueNumber,\n  repoFullName,\n}: {\n  eventId: string\n  workflowId: string\n  issueNumber: number\n  repoFullName: string\n}): Promise<LLMResponseWithPlan> {\n  const session = await n4j.getSession()\n  try {\n    const result = await session.executeWrite(\n      async (tx: ManagedTransaction) => {\n        // Label as Plan\n        const planNode = await labelEventAsPlan(tx, {\n          eventId,\n          status: \"draft\",\n          version: int(1),\n        })\n\n        // Create relationship\n        await createPlanImplementsIssue(tx, {\n          eventId,\n          issueNumber: int(issueNumber),\n          repoFullName,\n        })\n\n        return planNode\n      }\n    )\n\n    return {\n      plan: {\n        id: result.id,\n        status: result.status,\n        version: result.version.toNumber(),\n        editMessage: result.editMessage,\n      },\n      workflowId,\n      id: result.id,\n      content: result.content,\n      type: \"llmResponseWithPlan\",\n      createdAt: result.createdAt.toStandardDate(),\n    }\n  } finally {\n    await session.close()\n  }\n}\n\nexport async function getPlanWithDetails(\n  planId: string\n): Promise<{ plan: Plan; workflow: WorkflowRun; issue: Issue }> {\n  const session = await n4j.getSession()\n  try {\n    const result = await session.executeRead(async (tx: ManagedTransaction) => {\n      return await dbGetPlanWithDetails(tx, { planId })\n    })\n\n    return {\n      plan: toAppPlan(result.plan),\n      workflow: toAppWorkflowRun(result.workflow),\n      issue: toAppIssue(result.issue),\n    }\n  } finally {\n    await session.close()\n  }\n}\n\n// Batch plan status for multiple issues (service level)\nexport async function getPlanStatusForIssues({\n  repoFullName,\n  issueNumbers,\n}: {\n  repoFullName: string\n  issueNumbers: number[]\n}): Promise<Record<number, boolean>> {\n  if (!issueNumbers.length) return {}\n  const session = await n4j.getSession()\n  try {\n    return await session.executeRead(async (tx: ManagedTransaction) => {\n      return await dbListPlanStatusForIssues(tx, { repoFullName, issueNumbers })\n    })\n  } finally {\n    await session.close()\n  }\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_p7TLlMFbeD1EY7xGwnsGH8hL",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "4613aefb-ff39-4564-8771-eef097300343",
    "createdAt": "2025-06-10T06:35:29.606Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_owlYH1LaoRWr3H1ejpp2uaKN",
    "args": "{\"relativePath\": \"lib/types/github.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "77f493ee-c30f-4fb3-8c57-436b6e355a98",
    "createdAt": "2025-06-10T06:35:29.630Z",
    "content": "import { components } from \"@octokit/openapi-types\"\nimport { RestEndpointMethodTypes } from \"@octokit/rest\"\nimport { z } from \"zod\"\n\n// GitHub API Types\nexport type GitHubRepository = components[\"schemas\"][\"full-repository\"]\nexport type AuthenticatedUserRepository = components[\"schemas\"][\"repository\"]\nexport type GitHubUser = components[\"schemas\"][\"simple-user\"]\nexport type GitHubIssue = components[\"schemas\"][\"issue\"]\nexport type GitHubIssueComment = components[\"schemas\"][\"issue-comment\"]\nexport type IssueComment =\n  RestEndpointMethodTypes[\"issues\"][\"listComments\"][\"response\"][\"data\"][0]\n\nexport type PullRequestList =\n  RestEndpointMethodTypes[\"pulls\"][\"list\"][\"response\"][\"data\"]\nexport type PullRequestSingle =\n  RestEndpointMethodTypes[\"pulls\"][\"get\"][\"response\"][\"data\"]\nexport type PullRequest = PullRequestSingle | PullRequestList[0]\n\nexport type PullRequestReview =\n  RestEndpointMethodTypes[\"pulls\"][\"listReviews\"][\"response\"][\"data\"][0]\nexport type PullRequestReviewComment =\n  RestEndpointMethodTypes[\"pulls\"][\"listReviewComments\"][\"response\"][\"data\"][0]\nexport type ListForRepoParams =\n  RestEndpointMethodTypes[\"issues\"][\"listForRepo\"][\"parameters\"]\nexport type SearchCodeItem = components[\"schemas\"][\"code-search-result-item\"]\n\n// Repository-specific types\nexport const repoFullNameSchema = z\n  .string()\n  .regex(/^[^/]+\\/[^/]+$/, 'Repository name must be in the format \"owner/repo\"')\n  .transform((str) => {\n    const [owner, repo] = str.split(\"/\")\n    return {\n      owner,\n      repo,\n      fullName: str,\n    }\n  })\n\nexport type RepoFullName = z.infer<typeof repoFullNameSchema>\n\n// Repository permissions types\nexport interface RepoPermissions {\n  canPush: boolean\n  canCreatePR: boolean\n  reason?: string\n}\n\n// Application-specific types\nexport type WorkflowType =\n  | \"Generating Plan...\"\n  | \"Creating PR...\"\n  | \"Reviewing PR...\"\n  | \"Identifying Goal...\"\n\n// Extended types for our application\nexport type GitHubItem = GitHubIssue & {\n  type: \"issue\" | \"pull\"\n}\n\n// zod\nexport const IssueOrderFieldSchema = z\n  .enum([\"CREATED\", \"UPDATED\", \"INTERACTIONS\", \"REACTIONS\"])\n  .default(\"CREATED\")\nexport type IssueOrderField = z.infer<typeof IssueOrderFieldSchema>\n\nexport type RepoSelectorItem = {\n  name: string\n  nameWithOwner: string\n  description: string | null\n  updatedAt: string\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_owlYH1LaoRWr3H1ejpp2uaKN",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "8bc79ed7-f7b8-46d3-a36f-cc032bccfcf9",
    "createdAt": "2025-06-10T06:35:29.702Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_bNL796pP6ZQjgJhmOkEtW0u3",
    "args": "{\"relativePath\": \"lib/webhook.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "0ac085f5-01f5-460c-b165-7e1c60a0d269",
    "createdAt": "2025-06-10T06:35:29.726Z",
    "content": "import { v4 as uuidv4 } from \"uuid\"\n\nimport { getRepoFromString } from \"@/lib/github/content\"\nimport { updateJobStatus } from \"@/lib/redis-old\"\nimport commentOnIssue from \"@/lib/workflows/commentOnIssue\"\n\nconst POST_TO_GITHUB_SETTING = true // TODO: Set setting in database\n\n// Subscribed events for Github App\nenum GitHubEvent {\n  Create = \"create\",\n  Delete = \"delete\",\n  Installation = \"installation\",\n  InstallationRepositories = \"installation_repositories\",\n  InstallationTarget = \"installation_target\",\n  Issues = \"issues\",\n  IssueComment = \"issue_comment\",\n  PullRequest = \"pull_request\",\n  PullRequestReview = \"pull_request_review\",\n  PullRequestReviewComment = \"pull_request_review_comment\",\n  PullRequestReviewThread = \"pull_request_review_thread\",\n  Push = \"push\",\n  Repository = \"repository\",\n}\n\nexport const routeWebhookHandler = async ({\n  event,\n  payload,\n}: {\n  event: string\n  payload: object\n}) => {\n  if (!Object.values(GitHubEvent).includes(event as GitHubEvent)) {\n    console.error(\"Invalid event type:\", event)\n    return\n  }\n\n  if (event === GitHubEvent.Issues) {\n    if (typeof process.env.OPENAI_API_KEY !== \"string\") {\n      throw new Error(\"OPENAI_API_KEY is not set\")\n    }\n\n    const action = payload[\"action\"]\n    if (action === \"opened\") {\n      // Generate a unique job ID\n      const jobId = uuidv4()\n      await updateJobStatus(\n        jobId,\n        \"Received webhook event for new issue. Starting commentOnIssue workflow.\"\n      )\n\n      const repo = await getRepoFromString(payload[\"repository\"][\"full_name\"])\n      commentOnIssue(\n        payload[\"issue\"][\"number\"],\n        repo,\n        process.env.OPENAI_API_KEY, // TODO: Pull API key from user account\n        jobId,\n        POST_TO_GITHUB_SETTING\n      )\n    }\n  } else {\n    const repository =\n      payload[\"repository\"]?.[\"full_name\"] || \"<unknown repository>\"\n    console.log(`${event} event received on ${repository}`)\n  }\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_bNL796pP6ZQjgJhmOkEtW0u3",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "e32c0b77-b922-4d85-bf52-b6fdea262c36",
    "createdAt": "2025-06-10T06:35:32.056Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_YFm2GAhoP7DTX32ndElxOl8z",
    "args": "{\"relativePath\":\"lib/types/db/neo4j.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "144dfa79-447d-4623-b092-2c2c53c60662",
    "createdAt": "2025-06-10T06:35:32.087Z",
    "content": "import { DateTime, Integer } from \"neo4j-driver\"\nimport { z } from \"zod\"\n\nimport {\n  errorEventSchema as appErrorEventSchema,\n  issueSchema as appIssueSchema,\n  llmResponseSchema as appLLMResponseSchema,\n  planSchema as appPlanSchema,\n  reviewCommentSchema as appReviewCommentSchema,\n  statusEventSchema as appStatusEventSchema,\n  systemPromptSchema as appSystemPromptSchema,\n  toolCallResultSchema as appToolCallResultSchema,\n  toolCallSchema as appToolCallSchema,\n  userMessageSchema as appUserMessageSchema,\n  workflowRunSchema as appWorkflowRunSchema,\n  WorkflowRunState,\n  workflowRunStateSchema,\n  workflowStateEventSchema as appWorkflowStateEventSchema,\n  WorkflowType,\n  workflowTypeEnum,\n} from \"@/lib/types\"\n\n// Re-export for Neo4j DB layer\nexport { workflowRunStateSchema, workflowTypeEnum }\nexport type { WorkflowRunState, WorkflowType }\n\n// Neo4j data model schemas\nexport const issueSchema = appIssueSchema\n  .omit({\n    createdAt: true,\n    updatedAt: true,\n    title: true,\n    body: true,\n    state: true,\n    labels: true,\n    assignees: true,\n  })\n  .merge(\n    z.object({\n      number: z.instanceof(Integer),\n    })\n  )\n\nexport const workflowRunSchema = appWorkflowRunSchema.merge(\n  z.object({\n    createdAt: z.instanceof(DateTime),\n  })\n)\n\nexport const planSchema = appPlanSchema.merge(\n  z.object({\n    version: z.instanceof(Integer),\n    createdAt: z.instanceof(DateTime),\n  })\n)\n\n// Event schemas\nexport const errorEventSchema = appErrorEventSchema\n  .merge(\n    z.object({\n      createdAt: z.instanceof(DateTime),\n    })\n  )\n  .omit({\n    workflowId: true,\n  })\n\nexport const statusEventSchema = appStatusEventSchema\n  .merge(\n    z.object({\n      createdAt: z.instanceof(DateTime),\n    })\n  )\n  .omit({\n    workflowId: true,\n  })\n\nexport const workflowStateEventSchema = appWorkflowStateEventSchema\n  .omit({ workflowId: true })\n  .merge(z.object({ createdAt: z.instanceof(DateTime) }))\n\nexport const systemPromptSchema = appSystemPromptSchema\n  .omit({ workflowId: true })\n  .merge(z.object({ createdAt: z.instanceof(DateTime) }))\n\nexport const userMessageSchema = appUserMessageSchema\n  .omit({ workflowId: true })\n  .merge(z.object({ createdAt: z.instanceof(DateTime) }))\n\nexport const llmResponseSchema = appLLMResponseSchema\n  .omit({ workflowId: true })\n  .merge(z.object({ createdAt: z.instanceof(DateTime) }))\n\nexport const llmResponseWithPlanSchema = llmResponseSchema.merge(\n  planSchema.omit({ createdAt: true })\n)\n\nexport const toolCallSchema = appToolCallSchema\n  .omit({ workflowId: true })\n  .merge(z.object({ createdAt: z.instanceof(DateTime) }))\n\nexport const toolCallResultSchema = appToolCallResultSchema\n  .omit({ workflowId: true })\n  .merge(z.object({ createdAt: z.instanceof(DateTime) }))\n\nexport const reviewCommentSchema = appReviewCommentSchema\n  .omit({ workflowId: true })\n  .merge(z.object({ createdAt: z.instanceof(DateTime) }))\n\nexport const messageEventSchema = z.union([\n  llmResponseWithPlanSchema,\n  z.discriminatedUnion(\"type\", [\n    userMessageSchema,\n    systemPromptSchema,\n    llmResponseSchema,\n    toolCallSchema,\n    toolCallResultSchema,\n  ]),\n])\n\nexport const anyEventSchema = z.discriminatedUnion(\"type\", [\n  errorEventSchema,\n  llmResponseSchema,\n  reviewCommentSchema,\n  statusEventSchema,\n  systemPromptSchema,\n  toolCallResultSchema,\n  toolCallSchema,\n  userMessageSchema,\n  workflowStateEventSchema,\n])\n\nexport type AnyEvent = z.infer<typeof anyEventSchema>\nexport type ErrorEvent = z.infer<typeof errorEventSchema>\nexport type Issue = z.infer<typeof issueSchema>\nexport type LLMResponse = z.infer<typeof llmResponseSchema>\nexport type LLMResponseWithPlan = z.infer<typeof llmResponseWithPlanSchema>\nexport type MessageEvent = z.infer<typeof messageEventSchema>\nexport type Plan = z.infer<typeof planSchema>\nexport type ReviewComment = z.infer<typeof reviewCommentSchema>\nexport type StatusEvent = z.infer<typeof statusEventSchema>\nexport type SystemPrompt = z.infer<typeof systemPromptSchema>\nexport type ToolCall = z.infer<typeof toolCallSchema>\nexport type ToolCallResult = z.infer<typeof toolCallResultSchema>\nexport type UserMessage = z.infer<typeof userMessageSchema>\nexport type WorkflowRun = z.infer<typeof workflowRunSchema>\nexport type WorkflowStateEvent = z.infer<typeof workflowStateEventSchema>\n\nexport function isLLMResponseWithPlan(\n  event: LLMResponse\n): event is LLMResponseWithPlan {\n  return llmResponseWithPlanSchema.safeParse(event).success\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_YFm2GAhoP7DTX32ndElxOl8z",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "fc6b9817-b891-4c44-8c49-4b18a1aa3c23",
    "createdAt": "2025-06-10T06:35:33.131Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_b1ngugWZvS6bxhwwRn9I9A5E",
    "args": "{\"relativePath\":\"lib/types/index.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "3d6cc91c-b0d1-4420-889c-3768d28fd62c",
    "createdAt": "2025-06-10T06:35:33.157Z",
    "content": "import { ChatModel } from \"openai/resources\"\nimport { z, ZodType } from \"zod\"\n\n// Tools\nexport interface Tool<Schema extends ZodType, Output> {\n  type: \"function\"\n  function: {\n    name: string\n    parameters: Record<string, unknown>\n    description: string\n  }\n  schema: Schema\n  handler: (params: z.infer<Schema>) => Promise<Output> | Output\n}\n\n// Agents\nexport type AgentConstructorParams = {\n  model?: ChatModel\n  systemPrompt?: string\n  apiKey?: string\n}\n\n// Issues\nexport const issueSchema = z.object({\n  number: z.number(),\n  createdAt: z.date().optional(),\n  repoFullName: z.string(),\n  title: z.string().optional(),\n  body: z.string().optional(),\n  state: z.enum([\"open\", \"closed\"]).optional(),\n  labels: z.array(z.string()).optional(),\n  assignees: z.array(z.string()).optional(),\n  updatedAt: z.date().optional(),\n})\n\n// WorkflowRuns\nexport const workflowTypeEnum = z.enum([\n  \"commentOnIssue\",\n  \"resolveIssue\",\n  \"identifyPRGoal\",\n  \"reviewPullRequest\",\n  \"alignmentCheck\",\n])\n\nexport const workflowRunSchema = z.object({\n  id: z.string(),\n  type: workflowTypeEnum,\n  createdAt: z.date(),\n  postToGithub: z.boolean().optional(),\n})\n\n// Plans\nexport const planSchema = z.object({\n  id: z.string(),\n  content: z.string(),\n  status: z.enum([\"draft\", \"approved\", \"rejected\"]),\n  version: z.number(),\n  createdAt: z.date(),\n  editMessage: z.string().optional(),\n})\n\nexport const planMetaSchema = planSchema.omit({\n  content: true,\n  createdAt: true,\n})\n\n// Events\nconst eventTypes = z.enum([\n  \"error\",\n  \"llmResponse\",\n  \"llmResponseWithPlan\",\n  \"message\",\n  \"reviewComment\",\n  \"status\",\n  \"systemPrompt\",\n  \"toolCall\",\n  \"toolCallResult\",\n  \"userMessage\",\n  \"workflowState\",\n])\n\nexport const baseEventSchema = z.object({\n  id: z.string(),\n  createdAt: z.date(),\n  workflowId: z.string(),\n  content: z.string().optional(),\n  type: eventTypes,\n})\n\nexport const llmResponseSchema = baseEventSchema.merge(\n  z.object({\n    type: z.literal(\"llmResponse\"),\n    content: z.string(),\n    model: z\n      .string()\n      .optional()\n      .describe(\"String description of LLM model used to generate response\"),\n  })\n)\n\nexport const llmResponseWithPlanSchema = baseEventSchema.merge(\n  z.object({\n    type: z.literal(\"llmResponseWithPlan\"),\n    content: z.string(),\n    plan: planMetaSchema,\n  })\n)\n\nexport const statusEventSchema = baseEventSchema.extend({\n  type: z.literal(\"status\"),\n  content: z.string(),\n})\n\nexport const systemPromptSchema = baseEventSchema.extend({\n  type: z.literal(\"systemPrompt\"),\n  content: z.string(),\n})\n\nexport const userMessageSchema = baseEventSchema.extend({\n  type: z.literal(\"userMessage\"),\n  content: z.string(),\n})\n\nexport const toolCallSchema = baseEventSchema.extend({\n  type: z.literal(\"toolCall\"),\n  toolName: z.string(),\n  toolCallId: z.string(),\n  args: z.string(),\n})\n\nexport const toolCallResultSchema = baseEventSchema.extend({\n  type: z.literal(\"toolCallResult\"),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  content: z.string(),\n})\n\n// TODO: Change 'running' to 'inProgress'\nexport const workflowRunStateSchema = z.enum([\"running\", \"completed\", \"error\"])\n\nexport const workflowStateEventSchema = baseEventSchema.extend({\n  type: z.literal(\"workflowState\"),\n  state: workflowRunStateSchema,\n})\n\nexport const reviewCommentSchema = baseEventSchema.extend({\n  type: z.literal(\"reviewComment\"),\n  content: z.string(),\n  planId: z.string(),\n})\n\nexport const errorEventSchema = baseEventSchema.extend({\n  type: z.literal(\"error\"),\n  content: z.string(),\n})\n\nexport const messageEventSchema = z.discriminatedUnion(\"type\", [\n  userMessageSchema,\n  systemPromptSchema,\n  llmResponseSchema,\n  llmResponseWithPlanSchema,\n  toolCallSchema,\n  toolCallResultSchema,\n])\n\nexport const anyEventSchema = z.discriminatedUnion(\"type\", [\n  ...messageEventSchema.options,\n  errorEventSchema,\n  reviewCommentSchema,\n  statusEventSchema,\n  workflowStateEventSchema,\n])\n\n// ---- Settings Schemas ----\n\n/**\n * Base settings schema.\n * All properties optional. Add more user-specific settings as needed.\n */\nexport const settingsTypeEnum = z.enum([\"user\", \"repo\"])\n\nexport const settingsSchema = z.object({\n  type: settingsTypeEnum,\n  openAIApiKey: z\n    .string()\n    .optional()\n    .describe(\n      \"OpenAI API key used throughout the application (user-specific, optional).\"\n    ),\n  autoPostPlanToGitHubIssue: z\n    .boolean()\n    .optional()\n    .describe(\n      \"If true, the system will auto-post plans to GitHub issues for this user.\"\n    ),\n  lastUpdated: z\n    .date()\n    .describe(\"The date and time when the settings were last updated.\")\n    .default(new Date()),\n  // Add more user-specific settings here as needed\n})\n\n// Blog Posts\nexport const blogPostSchema = z.object({\n  slug: z.string().optional(),\n  title: z.string().optional(),\n  date: z.date().nullable().optional(),\n  summary: z.string().optional(),\n})\n\n// Type exports\nexport type AnyEvent = z.infer<typeof anyEventSchema>\nexport type BaseEvent = z.infer<typeof baseEventSchema>\nexport type BlogPost = z.infer<typeof blogPostSchema>\nexport type ErrorEvent = z.infer<typeof errorEventSchema>\nexport type EventTypes = z.infer<typeof eventTypes>\nexport type Issue = z.infer<typeof issueSchema>\nexport type LLMResponse = z.infer<typeof llmResponseSchema>\nexport type LLMResponseWithPlan = z.infer<typeof llmResponseWithPlanSchema>\nexport type MessageEvent = z.infer<typeof messageEventSchema>\nexport type Plan = z.infer<typeof planSchema>\nexport type PlanMeta = z.infer<typeof planMetaSchema>\nexport type ReviewComment = z.infer<typeof reviewCommentSchema>\nexport type Settings = z.infer<typeof settingsSchema>\nexport type SettingsType = z.infer<typeof settingsTypeEnum>\nexport type StatusEvent = z.infer<typeof statusEventSchema>\nexport type SystemPrompt = z.infer<typeof systemPromptSchema>\nexport type ToolCall = z.infer<typeof toolCallSchema>\nexport type ToolCallResult = z.infer<typeof toolCallResultSchema>\nexport type UserMessage = z.infer<typeof userMessageSchema>\nexport type WorkflowRun = z.infer<typeof workflowRunSchema>\nexport type WorkflowRunState = z.infer<typeof workflowRunStateSchema>\nexport type WorkflowStateEvent = z.infer<typeof workflowStateEventSchema>\nexport type WorkflowType = z.infer<typeof workflowTypeEnum>\n",
    "type": "toolCallResult",
    "toolCallId": "call_b1ngugWZvS6bxhwwRn9I9A5E",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "6bb90cb4-8d0a-4761-a50b-f899d9675e61",
    "createdAt": "2025-06-10T06:35:35.588Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_iUqZ1tbRC8MUWlkExWSoKFvy",
    "args": "{\"relativePath\":\"components/issues/actions/PostToGitHubButton.tsx\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "5f3caa8a-03c3-4cf5-b3c3-03b8da996b93",
    "createdAt": "2025-06-10T06:35:35.622Z",
    "content": "\"use client\"\n\nimport { useState } from \"react\"\n\nimport { Button } from \"@/components/ui/button\"\nimport { toast } from \"@/lib/hooks/use-toast\"\nimport { Issue } from \"@/lib/types\"\nimport { PostPlanRequest } from \"@/lib/types/api/schemas\"\n\ninterface Props {\n  content: string\n  issue: Issue\n}\n\nexport function PostToGitHubButton({ content, issue }: Props) {\n  const [isPosting, setIsPosting] = useState(false)\n\n  const handlePostToGithub = async () => {\n    try {\n      setIsPosting(true)\n\n      const requestBody: PostPlanRequest = {\n        content,\n        repoFullName: issue.repoFullName,\n        issueNumber: issue.number,\n      }\n\n      const response = await fetch(`/api/issues/${issue.number}/comments`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(requestBody),\n      })\n\n      if (!response.ok) {\n        throw new Error(\n          `Failed to post comment to GitHub: ${response.statusText}`\n        )\n      }\n\n      const data = await response.json()\n\n      toast({\n        title: \"Comment Posted\",\n        description: (\n          <div>\n            Your comment has been posted.{\" \"}\n            <a\n              href={data.commentUrl}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              className=\"underline font-medium\"\n            >\n              View on GitHub\n            </a>\n          </div>\n        ),\n      })\n    } catch (error) {\n      console.error(\"Error posting comment:\", error)\n      toast({\n        title: \"Error\",\n        description:\n          error instanceof Error\n            ? error.message\n            : \"Failed to post comment to GitHub\",\n        variant: \"destructive\",\n      })\n    } finally {\n      setIsPosting(false)\n    }\n  }\n\n  return (\n    <Button\n      variant=\"outline\"\n      size=\"sm\"\n      onClick={handlePostToGithub}\n      disabled={isPosting}\n    >\n      {isPosting ? \"Posting...\" : \"Post to GitHub\"}\n    </Button>\n  )\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_iUqZ1tbRC8MUWlkExWSoKFvy",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "2096982b-7592-49de-903d-6c4c4d09fa77",
    "createdAt": "2025-06-10T06:35:37.614Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_Uj8HIyMxPyFbnbL8bd8uxq3D",
    "args": "{\"relativePath\":\"app/api/issues/[issueId]/comments/route.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "01f140b4-3761-470a-96ae-eabd61013687",
    "createdAt": "2025-06-10T06:35:37.644Z",
    "content": "import { NextRequest, NextResponse } from \"next/server\"\nimport { z } from \"zod\"\n\nimport { createIssueComment } from \"@/lib/github/issues\"\nimport { PostPlanRequestSchema } from \"@/lib/types/api/schemas\"\n\nexport async function POST(\n  req: NextRequest,\n  { params }: { params: { issueId: string } }\n) {\n  try {\n    const body = await req.json()\n    const { content, repoFullName } = PostPlanRequestSchema.parse(body)\n    const issueNumber = parseInt(params.issueId)\n\n    // Post the plan as a comment\n    const comment = await createIssueComment({\n      issueNumber,\n      repoFullName,\n      comment: content,\n    })\n\n    return NextResponse.json({\n      success: true,\n      commentId: comment.id,\n      commentUrl: comment.html_url,\n    })\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json(\n        {\n          error: \"Invalid request data\",\n          details: error.errors,\n        },\n        { status: 400 }\n      )\n    }\n    console.error(\"Error posting plan:\", error)\n    return NextResponse.json({ error: \"Failed to post plan\" }, { status: 500 })\n  }\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_Uj8HIyMxPyFbnbL8bd8uxq3D",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "deca677e-c57e-47b3-acbf-89de2dbb6a0e",
    "createdAt": "2025-06-10T06:35:39.061Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_I8U0bw6qnlmnF7RR8GulaqpC",
    "args": "{\"relativePath\":\"lib/github/issues.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "eedfaa7d-147a-4f74-b604-cc80e2e4b247",
    "createdAt": "2025-06-10T06:35:39.095Z",
    "content": "\"use server\"\n\nimport getOctokit from \"@/lib/github\"\nimport { getPRLinkedIssuesMap } from \"@/lib/github/pullRequests\"\nimport { getPlanStatusForIssues } from \"@/lib/neo4j/services/plan\"\nimport {\n  GitHubIssue,\n  GitHubIssueComment,\n  ListForRepoParams,\n  RepoFullName,\n} from \"@/lib/types/github\"\n\nexport async function createIssue({\n  repoFullName,\n  title,\n  body,\n}: {\n  repoFullName: RepoFullName\n  title: string\n  body: string\n}) {\n  const octokit = await getOctokit()\n  const { owner, repo } = repoFullName\n  if (!octokit) throw new Error(\"No octokit found\")\n  return await octokit.rest.issues.create({ owner, repo, title, body })\n}\n\n// Existing: fetch single issue from GitHub\nexport async function getIssue({\n  fullName,\n  issueNumber,\n}: {\n  fullName: string\n  issueNumber: number\n}): Promise<GitHubIssue> {\n  const octokit = await getOctokit()\n  if (!octokit) {\n    throw new Error(\"No octokit found\")\n  }\n  const [owner, repo] = fullName.split(\"/\")\n  const issue = await octokit.rest.issues.get({\n    owner,\n    repo,\n    issue_number: issueNumber,\n  })\n  return issue.data\n}\n\nexport async function createIssueComment({\n  issueNumber,\n  repoFullName,\n  comment,\n}: {\n  issueNumber: number\n  repoFullName: string\n  comment: string\n}): Promise<GitHubIssueComment> {\n  const octokit = await getOctokit()\n  const [owner, repo] = repoFullName.split(\"/\")\n  if (!octokit) {\n    throw new Error(\"No octokit found\")\n  }\n  const issue = await octokit.rest.issues.createComment({\n    owner,\n    repo,\n    issue_number: issueNumber,\n    body: comment,\n  })\n  return issue.data\n}\n\nexport async function getIssueComments({\n  repoFullName,\n  issueNumber,\n}: {\n  repoFullName: string\n  issueNumber: number\n}): Promise<GitHubIssueComment[]> {\n  const octokit = await getOctokit()\n  const [owner, repo] = repoFullName.split(\"/\")\n  if (!owner || !repo) {\n    throw new Error(\"Invalid repository format. Expected 'owner/repo'\")\n  }\n  if (!octokit) {\n    throw new Error(\"No octokit found\")\n  }\n  const comments = await octokit.issues.listComments({\n    owner,\n    repo,\n    issue_number: issueNumber,\n  })\n  return comments.data as GitHubIssueComment[]\n}\n\nexport async function getIssueList({\n  repoFullName,\n  ...rest\n}: {\n  repoFullName: string\n} & Omit<ListForRepoParams, \"owner\" | \"repo\">): Promise<GitHubIssue[]> {\n  const octokit = await getOctokit()\n  const [owner, repo] = repoFullName.split(\"/\")\n\n  if (!octokit) {\n    throw new Error(\"No octokit found\")\n  }\n\n  const issues = await octokit.issues.listForRepo({\n    owner,\n    repo,\n    ...rest,\n  })\n  // Filter out pull requests from the list of issues\n  return issues.data.filter((issue) => !issue.pull_request)\n}\n\nexport async function updateIssueComment({\n  commentId,\n  repoFullName,\n  comment,\n}: {\n  commentId: number\n  repoFullName: string\n  comment: string\n}): Promise<GitHubIssueComment> {\n  const octokit = await getOctokit()\n  const [owner, repo] = repoFullName.split(\"/\")\n  if (!octokit) {\n    throw new Error(\"No octokit found\")\n  }\n  try {\n    const updatedComment = await octokit.rest.issues.updateComment({\n      owner,\n      repo,\n      comment_id: commentId,\n      body: comment,\n    })\n    return updatedComment.data\n  } catch (error) {\n    console.error(`Failed to update comment: ${commentId}`, error)\n    throw error\n  }\n}\n\n/**\n * Aggregates GitHub issues with Neo4j plan and PR status\n */\nexport type IssueWithStatus = GitHubIssue & {\n  hasPlan: boolean\n  hasPR: boolean\n}\n\n/**\n * For a repo, get list of issues with hasPlan and hasPR badges.\n */\nexport async function getIssueListWithStatus({\n  repoFullName,\n  ...rest\n}: {\n  repoFullName: string\n} & Omit<ListForRepoParams, \"owner\" | \"repo\">): Promise<IssueWithStatus[]> {\n  // 1. Get issues from GitHub\n  const issues = await getIssueList({ repoFullName, ...rest })\n\n  // 2. Query Neo4j for plans using the service layer\n  const issueNumbers = issues.map((issue) => issue.number)\n  const issuePlanStatus = await getPlanStatusForIssues({\n    repoFullName,\n    issueNumbers,\n  })\n\n  // 3. Get PRs from GitHub using GraphQL, and find for each issue if it has a PR referencing it.\n  const issuePRStatus = await getPRLinkedIssuesMap(repoFullName)\n\n  // 4. Compose the final list\n  const withStatus: IssueWithStatus[] = issues.map((issue) => ({\n    ...issue,\n    hasPlan: issuePlanStatus[issue.number] || false,\n    hasPR: issuePRStatus[issue.number] || false,\n  }))\n\n  return withStatus\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_I8U0bw6qnlmnF7RR8GulaqpC",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "d011095e-d8a8-4789-a78c-14986dcd9aa9",
    "createdAt": "2025-06-10T06:35:40.796Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_JZjFaLM7G9R7Yv0pnIj9WqJe",
    "args": "{\"relativePath\": \"lib/types/api/schemas.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "6d09debc-89eb-4f15-aa7b-41c52333e485",
    "createdAt": "2025-06-10T06:35:40.860Z",
    "content": "// TODO: Move API route schemas here, can be used by both client and server\n\nimport { z } from \"zod\"\n\nexport const PostPlanRequestSchema = z.object({\n  issueNumber: z.number(),\n  content: z.string().min(1),\n  repoFullName: z.string().min(1),\n})\nexport type PostPlanRequest = z.infer<typeof PostPlanRequestSchema>\n\nexport const AlignmentCheckRequestSchema = z.object({\n  repoFullName: z.string().min(1),\n  pullNumber: z.number(),\n  openAIApiKey: z.string(),\n})\nexport type AlignmentCheckRequest = z.infer<typeof AlignmentCheckRequestSchema>\n\nexport const AlignmentCheckResponseSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n})\nexport type AlignmentCheckResponse = z.infer<\n  typeof AlignmentCheckResponseSchema\n>\n",
    "type": "toolCallResult",
    "toolCallId": "call_JZjFaLM7G9R7Yv0pnIj9WqJe",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "447c9c4d-fedc-4cbe-a21d-b4ddbd28088f",
    "createdAt": "2025-06-10T06:35:40.899Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_RsYAXP0ebAY7IFeX47w4DnFq",
    "args": "{\"relativePath\": \"lib/neo4j/repositories/event.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "bd8749c5-f409-4276-b31d-c0f113780a0d",
    "createdAt": "2025-06-10T06:35:40.921Z",
    "content": "import { Integer, ManagedTransaction, Node } from \"neo4j-driver\"\n\nimport {\n  AnyEvent as appAnyEvent,\n  MessageEvent as appMessageEvent,\n} from \"@/lib/types\"\nimport {\n  AnyEvent,\n  anyEventSchema,\n  ErrorEvent,\n  errorEventSchema,\n  isLLMResponseWithPlan,\n  LLMResponse,\n  llmResponseSchema,\n  MessageEvent,\n  messageEventSchema,\n  StatusEvent,\n  statusEventSchema,\n  SystemPrompt,\n  systemPromptSchema,\n  ToolCall,\n  ToolCallResult,\n  toolCallResultSchema,\n  toolCallSchema,\n  UserMessage,\n  userMessageSchema,\n  WorkflowStateEvent,\n  workflowStateEventSchema,\n} from \"@/lib/types/db/neo4j\"\n\nexport async function get(\n  tx: ManagedTransaction,\n  workflowId: string\n): Promise<AnyEvent> {\n  const result = await tx.run<{ e: Node<Integer, AnyEvent, \"Event\"> }>(\n    `\n    MATCH (e:Event {id: $eventId}) \n    RETURN e \n    LIMIT 1\n    `,\n    { eventId: workflowId }\n  )\n  const raw = result.records[0]?.get(\"e\")?.properties\n  return anyEventSchema.parse(raw)\n}\n\nexport async function createSystemPromptEvent(\n  tx: ManagedTransaction,\n  event: Omit<SystemPrompt, \"createdAt\">\n): Promise<SystemPrompt> {\n  const { id, type, content } = event\n  const result = await tx.run<{ e: Node<Integer, LLMResponse, \"Event\"> }>(\n    `\n      CREATE (e:Event:Message {id: $id, createdAt: datetime(), type: $type, content: $content})\n      RETURN e\n      `,\n    { id, type, content }\n  )\n  return systemPromptSchema.parse(result.records[0]?.get(\"e\")?.properties)\n}\n\nexport async function createLLMResponseEvent(\n  tx: ManagedTransaction,\n  event: Omit<LLMResponse, \"createdAt\">\n): Promise<LLMResponse> {\n  const { id, type, content } = event\n  const result = await tx.run<{ e: Node<Integer, LLMResponse, \"Event\"> }>(\n    `\n    CREATE (e:Event:Message {id: $id, createdAt: datetime(), type: $type, content: $content, model: $model})\n    RETURN e\n    `,\n    { id, type, content, model: event.model || null }\n  )\n  return llmResponseSchema.parse(result.records[0]?.get(\"e\")?.properties)\n}\n\nexport async function createUserResponseEvent(\n  tx: ManagedTransaction,\n  event: Omit<UserMessage, \"createdAt\">\n): Promise<UserMessage> {\n  const { id, type, content } = event\n  const result = await tx.run<{ e: Node<Integer, UserMessage, \"Event\"> }>(\n    `\n      CREATE (e:Event:Message {id: $id, createdAt: datetime(), type: $type, content: $content})\n      RETURN e\n      `,\n    { id, type, content }\n  )\n  return userMessageSchema.parse(result.records[0]?.get(\"e\")?.properties)\n}\n\nexport async function createToolCallEvent(\n  tx: ManagedTransaction,\n  event: Omit<ToolCall, \"createdAt\" | \"workflowId\">\n): Promise<ToolCall> {\n  const { id, type, toolName, toolCallId, args } = event\n  const result = await tx.run<{ e: Node<Integer, ToolCall, \"Event\"> }>(\n    `\n      CREATE (e:Event:Message {id: $id, createdAt: datetime(), type: $type, toolName: $toolName, toolCallId: $toolCallId, args: $args})\n      RETURN e\n      `,\n    { id, type, toolName, toolCallId, args }\n  )\n  return toolCallSchema.parse(result.records[0]?.get(\"e\")?.properties)\n}\n\nexport async function createToolCallResultEvent(\n  tx: ManagedTransaction,\n  event: Omit<ToolCallResult, \"createdAt\" | \"workflowId\">\n): Promise<ToolCallResult> {\n  const { id, type, toolCallId, toolName, content } = event\n  const result = await tx.run<{ e: Node<Integer, ToolCallResult, \"Event\"> }>(\n    `\n      CREATE (e:Event:Message {id: $id, createdAt: datetime(), type: $type, toolCallId: $toolCallId, toolName: $toolName, content: $content})\n      RETURN e\n      `,\n    { id, type, toolCallId, toolName, content }\n  )\n  return toolCallResultSchema.parse(result.records[0]?.get(\"e\")?.properties)\n}\n\nexport async function createStatusEvent(\n  tx: ManagedTransaction,\n  event: Omit<StatusEvent, \"createdAt\" | \"workflowId\" | \"type\">\n): Promise<StatusEvent> {\n  const { id, content } = event\n  const result = await tx.run<{ e: Node<Integer, StatusEvent, \"Event\"> }>(\n    `\n      CREATE (e:Event {id: $id, createdAt: datetime(), type: 'status', content: $content})\n      RETURN e\n      `,\n    { id, content }\n  )\n  return statusEventSchema.parse(result.records[0]?.get(\"e\")?.properties)\n}\n\nexport async function createErrorEvent(\n  tx: ManagedTransaction,\n  event: Omit<ErrorEvent, \"createdAt\" | \"workflowId\">\n): Promise<ErrorEvent> {\n  const { id, type, content } = event\n  const result = await tx.run<{ e: Node<Integer, ErrorEvent, \"Event\"> }>(\n    `\n      CREATE (e:Event {id: $id, createdAt: datetime(), type: $type, content: $content})\n      RETURN e\n      `,\n    { id, type, content }\n  )\n  return errorEventSchema.parse(result.records[0]?.get(\"e\")?.properties)\n}\n\nexport async function createWorkflowStateEvent(\n  tx: ManagedTransaction,\n  event: Omit<WorkflowStateEvent, \"createdAt\" | \"workflowId\" | \"type\">\n): Promise<WorkflowStateEvent> {\n  const { id, state, content } = event\n  const result = await tx.run<{\n    e: Node<Integer, WorkflowStateEvent, \"Event\">\n  }>(\n    `\n      CREATE (e:Event {id: $id, createdAt: datetime(), type: $type, state: $state, content: $content})\n      RETURN e\n      `,\n    { id, type: \"workflowState\", state, content: content || null }\n  )\n  return workflowStateEventSchema.parse(result.records[0]?.get(\"e\")?.properties)\n}\n\nexport async function findFirst(\n  tx: ManagedTransaction,\n  workflowId: string\n): Promise<ReturnType<typeof anyEventSchema.parse> | null> {\n  const result = await tx.run(\n    `MATCH (w:WorkflowRun {id: $workflowId})-[:STARTS_WITH]->(e:Event) RETURN e LIMIT 1`,\n    { workflowId }\n  )\n  const raw = result.records[0]?.get(\"e\")?.properties\n  return raw ? anyEventSchema.parse(raw) : null\n}\n\nexport async function findLast(\n  tx: ManagedTransaction,\n  workflowId: string\n): Promise<ReturnType<typeof anyEventSchema.parse> | null> {\n  const result = await tx.run(\n    `MATCH (w:WorkflowRun {id: $workflowId})-[:STARTS_WITH|NEXT*]->(e:Event) WHERE NOT (e)-[:NEXT]->() RETURN e LIMIT 1`,\n    { workflowId }\n  )\n  const raw = result.records[0]?.get(\"e\")?.properties\n  return raw ? anyEventSchema.parse(raw) : null\n}\n\nexport async function createStartsWith(\n  tx: ManagedTransaction,\n  workflowId: string,\n  eventId: string\n): Promise<void> {\n  await tx.run(\n    `MATCH (w:WorkflowRun {id: $workflowId}) MATCH (e:Event {id: $eventId}) CREATE (w)-[:STARTS_WITH]->(e)`,\n    { workflowId, eventId }\n  )\n}\n\n/**\n * Creates a NEXT relationship between two events.\n * If NEXT relationship already exists, it will be overwritten.\n * If either event does not exist, nothing will happen.\n */\nexport async function createNext(\n  tx: ManagedTransaction,\n  fromEventId: string,\n  toEventId: string\n): Promise<void> {\n  await tx.run(\n    `\n    MATCH (from:Event {id: $fromEventId})\n    OPTIONAL MATCH (to:Event {id: $toEventId})\n    MERGE (from)-[:NEXT]->(to)\n    `,\n    { fromEventId, toEventId }\n  )\n}\n\nexport async function connectToWorkflow(\n  tx: ManagedTransaction,\n  workflowId: string,\n  eventId: string,\n  parentId?: string\n): Promise<void> {\n  if (parentId) {\n    await createNext(tx, parentId, eventId)\n  } else {\n    const firstEvent = await findFirst(tx, workflowId)\n    if (!firstEvent) {\n      await createStartsWith(tx, workflowId, eventId)\n    } else {\n      const lastEvent = await findLast(tx, workflowId)\n      if (lastEvent) {\n        await createNext(tx, lastEvent.id, eventId)\n      } else {\n        console.error(\n          \"No last event found for workflow, did not create NEXT relationship\",\n          workflowId\n        )\n      }\n    }\n  }\n}\n\n/**\n * Finds the previous and next event IDs for a given event in the event chain.\n */\nexport async function findPrevAndNextEvent(\n  tx: ManagedTransaction,\n  eventId: string\n): Promise<{ prevId: string | null; nextId: string | null }> {\n  const result = await tx.run<{ prevId: string | null; nextId: string | null }>(\n    `\n    MATCH (e:Event {id: $eventId})\n    OPTIONAL MATCH (prev:Event)-[:NEXT]->(e)\n    OPTIONAL MATCH (e)-[:NEXT]->(next:Event)\n    RETURN prev.id AS prevId, next.id AS nextId\n    `,\n    { eventId }\n  )\n  const record = result.records[0]\n  return {\n    prevId: record?.get(\"prevId\"),\n    nextId: record?.get(\"nextId\"),\n  }\n}\n\n/**\n * Detaches and deletes event node.\n */\nexport async function deleteEventNode(\n  tx: ManagedTransaction,\n  eventId: string\n): Promise<void> {\n  await tx.run(\n    `\n    MATCH (e:Event {id: $eventId})\n    DETACH DELETE e\n    `,\n    { eventId }\n  )\n}\n\nexport async function getMessagesForWorkflowRun(\n  tx: ManagedTransaction,\n  workflowRunId: string\n): Promise<MessageEvent[]> {\n  const result = await tx.run<{ e: Node<Integer, MessageEvent, \"Event\"> }>(\n    `\n    MATCH (w:WorkflowRun {id: $workflowRunId})-[:STARTS_WITH|NEXT*]->(e:Event:Message)\n    RETURN e\n    ORDER BY e.createdAt ASC\n    `,\n    { workflowRunId }\n  )\n  return result.records.map((record) =>\n    messageEventSchema.parse(record.get(\"e\").properties)\n  )\n}\n\nexport async function toAppEvent(\n  dbEvent: AnyEvent,\n  workflowId: string\n): Promise<appAnyEvent> {\n  if (dbEvent.type === \"llmResponse\" && isLLMResponseWithPlan(dbEvent)) {\n    return {\n      ...dbEvent,\n      createdAt: dbEvent.createdAt.toStandardDate(),\n      type: \"llmResponseWithPlan\",\n      workflowId,\n      plan: {\n        id: dbEvent.id,\n        status: dbEvent.status,\n        version: dbEvent.version.toNumber(),\n        editMessage: dbEvent.editMessage,\n      },\n    }\n  }\n  return {\n    ...dbEvent,\n    createdAt: dbEvent.createdAt.toStandardDate(),\n    workflowId,\n  }\n}\n\nexport async function toAppMessageEvent(\n  dbEvent: MessageEvent,\n  workflowId: string\n): Promise<appMessageEvent> {\n  if (dbEvent.type === \"llmResponse\" && isLLMResponseWithPlan(dbEvent)) {\n    return {\n      ...dbEvent,\n      createdAt: dbEvent.createdAt.toStandardDate(),\n      type: \"llmResponseWithPlan\",\n      workflowId,\n      plan: {\n        id: dbEvent.id,\n        status: dbEvent.status,\n        version: dbEvent.version.toNumber(),\n        editMessage: dbEvent.editMessage,\n      },\n    }\n  }\n  return {\n    ...dbEvent,\n    createdAt: dbEvent.createdAt.toStandardDate(),\n    workflowId,\n  }\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_RsYAXP0ebAY7IFeX47w4DnFq",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "8bd50fac-9213-478c-a02b-fe02539fcffc",
    "createdAt": "2025-06-10T06:35:43.916Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_bP2AzSuZo5p7CHooZ322CtVM",
    "args": "{\"relativePath\":\"lib/types/plan.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "fc6313db-db34-43f8-96bf-edeb6b41fc3a",
    "createdAt": "2025-06-10T06:35:43.946Z",
    "content": "import { Integer, Node } from \"neo4j-driver\"\n\n/**\n * @deprecated This type is deprecated. Use types from the neo4j.ts file instead.\n */\nexport interface PlanProperties {\n  id: string\n  status: \"draft\" | \"approved\" | \"rejected\"\n  type: string\n  createdAt: Date\n}\n\n/**\n * @deprecated This type is deprecated. Use types from the neo4j.ts file instead.\n */\nexport type Plan = Node<Integer, PlanProperties>\n",
    "type": "toolCallResult",
    "toolCallId": "call_bP2AzSuZo5p7CHooZ322CtVM",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "f3aff352-0b3a-4249-aa27-fd952b7ef81a",
    "createdAt": "2025-06-10T06:35:45.689Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_lSu8PaZzvWzMcJVQiWIcss2X",
    "args": "{\"relativePath\":\"app/api/webhook/github/route.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "b615d885-e19d-4c4a-8559-5423fad19eca",
    "createdAt": "2025-06-10T06:35:45.737Z",
    "content": "import crypto from \"crypto\"\nimport { NextRequest } from \"next/server\"\n\nimport { runWithInstallationId } from \"@/lib/utils/utils-server\"\nimport { routeWebhookHandler } from \"@/lib/webhook\"\n\nasync function verifySignature(\n  signature: string,\n  payload: object,\n  secret: string\n) {\n  const hmac = crypto.createHmac(\"sha256\", secret)\n  hmac.update(JSON.stringify(payload))\n\n  const digest = `sha256=${hmac.digest(\"hex\")}`\n  return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(digest))\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    const signature = req.headers.get(\"x-hub-signature-256\") as string\n    const event = req.headers.get(\"x-github-event\") as string\n    const payload = (await req.json()) as object\n    const secret = process.env.GITHUB_WEBHOOK_SECRET\n\n    if (!secret) {\n      console.error(\"[ERROR] GITHUB_WEBHOOK_SECRET not configured\")\n      return new Response(\"Webhook secret not configured\", { status: 500 })\n    }\n\n    if (!verifySignature(signature, payload, secret)) {\n      console.error(\"[ERROR] Invalid webhook signature\")\n      return new Response(\"Invalid signature\", { status: 401 })\n    }\n\n    const installationId = payload[\"installation\"][\"id\"]\n    if (!installationId) {\n      console.error(\"[ERROR] No installation ID found in webhook payload\")\n      return new Response(\"No installation ID found\", { status: 400 })\n    }\n\n    // Route the payload to the appropriate handler\n    runWithInstallationId(installationId, async () => {\n      await routeWebhookHandler({\n        event,\n        payload,\n      })\n    })\n\n    // Respond with a success status\n    return new Response(\"Webhook received\", { status: 200 })\n  } catch (error) {\n    console.error(\"[ERROR] Error handling webhook:\", error)\n    return new Response(\"Error\", { status: 500 })\n  }\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_lSu8PaZzvWzMcJVQiWIcss2X",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "568f3996-1d31-4894-ab12-7d141facba85",
    "createdAt": "2025-06-10T06:35:47.472Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_K8rvOQC2PJZSDK521O5iPVbI",
    "args": "{\"relativePath\":\"components/issues/IssuePlans.tsx\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "f2f8d67d-4d54-43ae-9bf2-da992707b335",
    "createdAt": "2025-06-10T06:35:47.504Z",
    "content": "\"use server\"\n\nimport { ExternalLink } from \"lucide-react\"\nimport Link from \"next/link\"\n\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\"\nimport { listPlansForIssue } from \"@/lib/neo4j/services/plan\"\n\ninterface Props {\n  repoFullName: string\n  issueNumber: number\n}\n\nexport default async function IssuePlans({ repoFullName, issueNumber }: Props) {\n  const plans = await listPlansForIssue({\n    repoFullName,\n    issueNumber,\n  })\n\n  if (plans.length === 0) {\n    return null\n  }\n\n  // Just get the latest plan (for now)\n  const plan = plans.sort(\n    (a, b) => b.createdAt.getTime() - a.createdAt.getTime()\n  )[0]\n\n  const formatDate = (date: Date) => {\n    return new Intl.DateTimeFormat(\"en-US\", {\n      dateStyle: \"medium\",\n      timeStyle: \"short\",\n    }).format(date)\n  }\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle>Resolution Plan</CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"text-sm text-muted-foreground\">\n            Created on {formatDate(plan.createdAt)}\n          </div>\n          <Link href={`/${repoFullName}/issues/${issueNumber}/plan/${plan.id}`}>\n            <div className=\"flex items-center gap-2 text-sm text-primary hover:underline\">\n              <ExternalLink className=\"h-4 w-4\" />\n              View Full Plan\n            </div>\n          </Link>\n        </div>\n        <div className=\"text-sm\">\n          <div className=\"font-medium mb-2\">Status: {plan.status}</div>\n          <div className=\"whitespace-pre-wrap rounded-lg bg-muted p-4 max-h-48 overflow-y-auto\">\n            {plan.content}\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_K8rvOQC2PJZSDK521O5iPVbI",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "03cd239a-82ab-455f-b169-780e972670ad",
    "createdAt": "2025-06-10T06:35:50.195Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_8sehjTuIQNsWpXYSpsUtfoNI",
    "args": "{\"relativePath\":\"app/[username]/[repo]/issues/[issueId]/page.tsx\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "6bcc6c30-6a06-40aa-9c37-44ad613ff247",
    "createdAt": "2025-06-10T06:35:50.227Z",
    "content": "import { ChevronLeft } from \"lucide-react\"\nimport Link from \"next/link\"\nimport { notFound } from \"next/navigation\"\nimport { Suspense } from \"react\"\n\nimport IssueDetailsWrapper from \"@/components/issues/IssueDetailsWrapper\"\nimport IssuePlans from \"@/components/issues/IssuePlans\"\nimport IssueWorkflowRuns from \"@/components/issues/IssueWorkflowRuns\"\nimport TableSkeleton from \"@/components/layout/TableSkeleton\"\nimport { Button } from \"@/components/ui/button\"\nimport { getIssue } from \"@/lib/github/issues\"\nimport { GitHubIssue } from \"@/lib/types/github\"\n\ninterface Props {\n  params: {\n    username: string\n    repo: string\n    issueId: string\n  }\n}\n\nexport default async function IssueDetailsPage({ params }: Props) {\n  const { username, repo, issueId } = params\n  const repoFullName = `${username}/${repo}`\n  const issueNumber = parseInt(issueId)\n\n  let issue: GitHubIssue\n  try {\n    issue = await getIssue({\n      fullName: repoFullName,\n      issueNumber,\n    })\n  } catch (error) {\n    console.error(\"Error fetching issue:\", error)\n    notFound()\n  }\n\n  return (\n    <main className=\"container mx-auto p-4\">\n      <div className=\"flex flex-col gap-4 max-w-2xl mx-auto\">\n        <div className=\"flex items-center gap-4\">\n          <Link href={`/${username}/${repo}/issues`}>\n            <Button\n              variant=\"secondary\"\n              size=\"sm\"\n              className=\"gap-2 text-muted-foreground hover:text-foreground transition-colors\"\n            >\n              <ChevronLeft className=\"h-4 w-4\" />\n              Back to Issues\n            </Button>\n          </Link>\n          <h1 className=\"text-2xl font-bold\">\n            {repoFullName} - Issue #{issueNumber}\n          </h1>\n        </div>\n        <Suspense fallback={<TableSkeleton />}>\n          <IssueDetailsWrapper issue={issue} />\n        </Suspense>\n\n        <Suspense fallback={<TableSkeleton />}>\n          <IssuePlans repoFullName={repoFullName} issueNumber={issueNumber} />\n        </Suspense>\n\n        <Suspense fallback={<TableSkeleton />}>\n          <IssueWorkflowRuns\n            repoFullName={repoFullName}\n            issueNumber={issueNumber}\n          />\n        </Suspense>\n      </div>\n    </main>\n  )\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_8sehjTuIQNsWpXYSpsUtfoNI",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "85fb88bc-f2fc-48dd-8132-2d2621d9b647",
    "createdAt": "2025-06-10T06:35:52.052Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_sS6z6I4dkelEwThEpNkSLikw",
    "args": "{\"relativePath\":\"lib/types/db/plan.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "2a77b876-00d9-4703-aa63-a8c0d008022a",
    "createdAt": "2025-06-10T06:35:52.085Z",
    "content": "Error: ENOENT: no such file or directory, stat '/tmp/git-repos/youngchingjui/issue-to-pr/lib/types/db/plan.ts'",
    "type": "toolCallResult",
    "toolCallId": "call_sS6z6I4dkelEwThEpNkSLikw",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "4bc2523b-391e-4258-a679-ddb5b74168e7",
    "createdAt": "2025-06-10T06:35:54.146Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_2Ms7QJMsat0HIeAEFLx3BKOd",
    "args": "{\"relativePath\":\"lib/types/db/neo4j.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "d6b1ee15-056f-43e4-9962-5bb76df380bd",
    "createdAt": "2025-06-10T06:35:54.176Z",
    "content": "import { DateTime, Integer } from \"neo4j-driver\"\nimport { z } from \"zod\"\n\nimport {\n  errorEventSchema as appErrorEventSchema,\n  issueSchema as appIssueSchema,\n  llmResponseSchema as appLLMResponseSchema,\n  planSchema as appPlanSchema,\n  reviewCommentSchema as appReviewCommentSchema,\n  statusEventSchema as appStatusEventSchema,\n  systemPromptSchema as appSystemPromptSchema,\n  toolCallResultSchema as appToolCallResultSchema,\n  toolCallSchema as appToolCallSchema,\n  userMessageSchema as appUserMessageSchema,\n  workflowRunSchema as appWorkflowRunSchema,\n  WorkflowRunState,\n  workflowRunStateSchema,\n  workflowStateEventSchema as appWorkflowStateEventSchema,\n  WorkflowType,\n  workflowTypeEnum,\n} from \"@/lib/types\"\n\n// Re-export for Neo4j DB layer\nexport { workflowRunStateSchema, workflowTypeEnum }\nexport type { WorkflowRunState, WorkflowType }\n\n// Neo4j data model schemas\nexport const issueSchema = appIssueSchema\n  .omit({\n    createdAt: true,\n    updatedAt: true,\n    title: true,\n    body: true,\n    state: true,\n    labels: true,\n    assignees: true,\n  })\n  .merge(\n    z.object({\n      number: z.instanceof(Integer),\n    })\n  )\n\nexport const workflowRunSchema = appWorkflowRunSchema.merge(\n  z.object({\n    createdAt: z.instanceof(DateTime),\n  })\n)\n\nexport const planSchema = appPlanSchema.merge(\n  z.object({\n    version: z.instanceof(Integer),\n    createdAt: z.instanceof(DateTime),\n  })\n)\n\n// Event schemas\nexport const errorEventSchema = appErrorEventSchema\n  .merge(\n    z.object({\n      createdAt: z.instanceof(DateTime),\n    })\n  )\n  .omit({\n    workflowId: true,\n  })\n\nexport const statusEventSchema = appStatusEventSchema\n  .merge(\n    z.object({\n      createdAt: z.instanceof(DateTime),\n    })\n  )\n  .omit({\n    workflowId: true,\n  })\n\nexport const workflowStateEventSchema = appWorkflowStateEventSchema\n  .omit({ workflowId: true })\n  .merge(z.object({ createdAt: z.instanceof(DateTime) }))\n\nexport const systemPromptSchema = appSystemPromptSchema\n  .omit({ workflowId: true })\n  .merge(z.object({ createdAt: z.instanceof(DateTime) }))\n\nexport const userMessageSchema = appUserMessageSchema\n  .omit({ workflowId: true })\n  .merge(z.object({ createdAt: z.instanceof(DateTime) }))\n\nexport const llmResponseSchema = appLLMResponseSchema\n  .omit({ workflowId: true })\n  .merge(z.object({ createdAt: z.instanceof(DateTime) }))\n\nexport const llmResponseWithPlanSchema = llmResponseSchema.merge(\n  planSchema.omit({ createdAt: true })\n)\n\nexport const toolCallSchema = appToolCallSchema\n  .omit({ workflowId: true })\n  .merge(z.object({ createdAt: z.instanceof(DateTime) }))\n\nexport const toolCallResultSchema = appToolCallResultSchema\n  .omit({ workflowId: true })\n  .merge(z.object({ createdAt: z.instanceof(DateTime) }))\n\nexport const reviewCommentSchema = appReviewCommentSchema\n  .omit({ workflowId: true })\n  .merge(z.object({ createdAt: z.instanceof(DateTime) }))\n\nexport const messageEventSchema = z.union([\n  llmResponseWithPlanSchema,\n  z.discriminatedUnion(\"type\", [\n    userMessageSchema,\n    systemPromptSchema,\n    llmResponseSchema,\n    toolCallSchema,\n    toolCallResultSchema,\n  ]),\n])\n\nexport const anyEventSchema = z.discriminatedUnion(\"type\", [\n  errorEventSchema,\n  llmResponseSchema,\n  reviewCommentSchema,\n  statusEventSchema,\n  systemPromptSchema,\n  toolCallResultSchema,\n  toolCallSchema,\n  userMessageSchema,\n  workflowStateEventSchema,\n])\n\nexport type AnyEvent = z.infer<typeof anyEventSchema>\nexport type ErrorEvent = z.infer<typeof errorEventSchema>\nexport type Issue = z.infer<typeof issueSchema>\nexport type LLMResponse = z.infer<typeof llmResponseSchema>\nexport type LLMResponseWithPlan = z.infer<typeof llmResponseWithPlanSchema>\nexport type MessageEvent = z.infer<typeof messageEventSchema>\nexport type Plan = z.infer<typeof planSchema>\nexport type ReviewComment = z.infer<typeof reviewCommentSchema>\nexport type StatusEvent = z.infer<typeof statusEventSchema>\nexport type SystemPrompt = z.infer<typeof systemPromptSchema>\nexport type ToolCall = z.infer<typeof toolCallSchema>\nexport type ToolCallResult = z.infer<typeof toolCallResultSchema>\nexport type UserMessage = z.infer<typeof userMessageSchema>\nexport type WorkflowRun = z.infer<typeof workflowRunSchema>\nexport type WorkflowStateEvent = z.infer<typeof workflowStateEventSchema>\n\nexport function isLLMResponseWithPlan(\n  event: LLMResponse\n): event is LLMResponseWithPlan {\n  return llmResponseWithPlanSchema.safeParse(event).success\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_2Ms7QJMsat0HIeAEFLx3BKOd",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "a2cfdcc2-608a-4294-a251-a4276c5dde79",
    "createdAt": "2025-06-10T06:35:55.636Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_wcXO1duM00L3fPdGdHXEF7AQ",
    "args": "{\"relativePath\":\"app/[username]/[repo]/issues/[issueId]/plan/[planId]/page.tsx\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "a04f36cd-1e4a-40f9-982d-77208fd50827",
    "createdAt": "2025-06-10T06:35:55.661Z",
    "content": "import Link from \"next/link\"\nimport { notFound } from \"next/navigation\"\nimport ReactMarkdown from \"react-markdown\"\n\nimport {\n  Card,\n  CardContent,\n  CardDescription,\n  CardHeader,\n  CardTitle,\n} from \"@/components/ui/card\"\nimport { getPlanWithDetails } from \"@/lib/neo4j/services/plan\"\n\ninterface PageProps {\n  params: {\n    planId: string\n    issueId: string\n  }\n}\n\nexport default async function PlanPage({ params }: PageProps) {\n  const { planId } = params\n  const { plan, workflow, issue } = await getPlanWithDetails(planId)\n\n  if (!plan) {\n    notFound()\n  }\n\n  return (\n    <div className=\"flex min-h-screen items-start justify-center py-8 px-4\">\n      <Card className=\"w-full max-w-4xl\">\n        <CardHeader>\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <CardTitle>Plan Details</CardTitle>\n              <CardDescription>\n                Created on {plan.createdAt.toLocaleDateString()}\n              </CardDescription>\n            </div>\n          </div>\n        </CardHeader>\n        <CardContent className=\"space-y-6\">\n          <div>\n            <h3 className=\"text-lg font-semibold mb-2\">Plan Content</h3>\n            <div className=\"prose prose-sm dark:prose-invert max-w-none rounded-lg bg-muted p-4\">\n              <ReactMarkdown>{plan.content}</ReactMarkdown>\n            </div>\n          </div>\n\n          {issue && (\n            <div>\n              <h3 className=\"text-lg font-semibold mb-2\">Related Issue</h3>\n              <Link\n                href={`/${issue.repoFullName}/issues/${issue.number}`}\n                className=\"text-primary hover:underline\"\n              >\n                #{issue.number}\n              </Link>\n            </div>\n          )}\n\n          {workflow && (\n            <div>\n              <h3 className=\"text-lg font-semibold mb-2\">\n                Workflow Information\n              </h3>\n              <div>\n                <p>\n                  <strong>Type:</strong> {workflow.type}\n                </p>\n                <p>\n                  <strong>ID:</strong> {workflow.id}\n                </p>\n              </div>\n            </div>\n          )}\n\n          <div>\n            <h3 className=\"text-lg font-semibold mb-2\">Metadata</h3>\n            <div className=\"grid grid-cols-2 gap-4\">\n              <div>\n                <p>\n                  <strong>Status:</strong> {plan.status}\n                </p>\n              </div>\n              <div>\n                <p>\n                  <strong>Plan ID:</strong> {plan.id}\n                </p>\n                <p>\n                  <strong>Version:</strong> {plan.version}\n                </p>\n              </div>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n    </div>\n  )\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_wcXO1duM00L3fPdGdHXEF7AQ",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "f7b19b0f-aaa3-406b-9dd3-712c446f3604",
    "createdAt": "2025-06-10T06:35:57.095Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_ZE6a6WEnuuD3qweXDcXnFozB",
    "args": "{\"relativePath\":\"lib/neo4j/services/plan.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "0e78372b-5268-46fa-8e5b-fa1ec7135fb6",
    "createdAt": "2025-06-10T06:35:57.127Z",
    "content": "import { int, ManagedTransaction } from \"neo4j-driver\"\n\nimport { n4j } from \"@/lib/neo4j/client\"\nimport { toAppIssue } from \"@/lib/neo4j/repositories/issue\"\nimport {\n  createPlanImplementsIssue,\n  getPlanWithDetails as dbGetPlanWithDetails,\n  labelEventAsPlan,\n  listPlansForIssue as dbListPlansForIssue,\n  listPlanStatusForIssues as dbListPlanStatusForIssues,\n  toAppPlan,\n} from \"@/lib/neo4j/repositories/plan\"\nimport { toAppWorkflowRun } from \"@/lib/neo4j/repositories/workflowRun\"\nimport { Issue, LLMResponseWithPlan, Plan, WorkflowRun } from \"@/lib/types\"\n\nexport async function listPlansForIssue({\n  repoFullName,\n  issueNumber,\n}: {\n  repoFullName: string\n  issueNumber: number\n}) {\n  const session = await n4j.getSession()\n\n  try {\n    const result = await session.executeRead(async (tx: ManagedTransaction) => {\n      return await dbListPlansForIssue(tx, {\n        repoFullName,\n        issueNumber,\n      })\n    })\n    return result.map(toAppPlan)\n  } finally {\n    await session.close()\n  }\n}\n\n/**\n * Finds an existing event by eventId and labels it as a Plan, attaching default plan metadata (status, version, etc).\n * Then, links the labeled e:Event:Plan node to the underlying Issue node in the graph.\n */\nexport async function tagMessageAsPlan({\n  eventId,\n  workflowId,\n  issueNumber,\n  repoFullName,\n}: {\n  eventId: string\n  workflowId: string\n  issueNumber: number\n  repoFullName: string\n}): Promise<LLMResponseWithPlan> {\n  const session = await n4j.getSession()\n  try {\n    const result = await session.executeWrite(\n      async (tx: ManagedTransaction) => {\n        // Label as Plan\n        const planNode = await labelEventAsPlan(tx, {\n          eventId,\n          status: \"draft\",\n          version: int(1),\n        })\n\n        // Create relationship\n        await createPlanImplementsIssue(tx, {\n          eventId,\n          issueNumber: int(issueNumber),\n          repoFullName,\n        })\n\n        return planNode\n      }\n    )\n\n    return {\n      plan: {\n        id: result.id,\n        status: result.status,\n        version: result.version.toNumber(),\n        editMessage: result.editMessage,\n      },\n      workflowId,\n      id: result.id,\n      content: result.content,\n      type: \"llmResponseWithPlan\",\n      createdAt: result.createdAt.toStandardDate(),\n    }\n  } finally {\n    await session.close()\n  }\n}\n\nexport async function getPlanWithDetails(\n  planId: string\n): Promise<{ plan: Plan; workflow: WorkflowRun; issue: Issue }> {\n  const session = await n4j.getSession()\n  try {\n    const result = await session.executeRead(async (tx: ManagedTransaction) => {\n      return await dbGetPlanWithDetails(tx, { planId })\n    })\n\n    return {\n      plan: toAppPlan(result.plan),\n      workflow: toAppWorkflowRun(result.workflow),\n      issue: toAppIssue(result.issue),\n    }\n  } finally {\n    await session.close()\n  }\n}\n\n// Batch plan status for multiple issues (service level)\nexport async function getPlanStatusForIssues({\n  repoFullName,\n  issueNumbers,\n}: {\n  repoFullName: string\n  issueNumbers: number[]\n}): Promise<Record<number, boolean>> {\n  if (!issueNumbers.length) return {}\n  const session = await n4j.getSession()\n  try {\n    return await session.executeRead(async (tx: ManagedTransaction) => {\n      return await dbListPlanStatusForIssues(tx, { repoFullName, issueNumbers })\n    })\n  } finally {\n    await session.close()\n  }\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_ZE6a6WEnuuD3qweXDcXnFozB",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "b3366249-d35d-42ae-a6e9-d356392a6bcd",
    "createdAt": "2025-06-10T06:35:59.145Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_D7jADwgaysUdJqHWPLGeODvO",
    "args": "{\"relativePath\":\"lib/neo4j/repositories/plan.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "ea5c0b11-545a-4897-8a76-385652d9d6bb",
    "createdAt": "2025-06-10T06:35:59.179Z",
    "content": "import { int, Integer, ManagedTransaction, Node } from \"neo4j-driver\"\nimport { z } from \"zod\"\n\nimport { Plan as AppPlan } from \"@/lib/types\"\nimport {\n  Issue,\n  issueSchema,\n  LLMResponseWithPlan,\n  llmResponseWithPlanSchema,\n  Plan,\n  planSchema,\n  WorkflowRun,\n  workflowRunSchema,\n} from \"@/lib/types/db/neo4j\"\n\n// Retrieve Event node by id\nexport async function getEventById(\n  tx: ManagedTransaction,\n  { eventId }: { eventId: string }\n) {\n  //TODO: Implement this\n}\n\nexport async function listPlansForIssue(\n  tx: ManagedTransaction,\n  { repoFullName, issueNumber }: { repoFullName: string; issueNumber: number }\n) {\n  const result = await tx.run<{\n    p: Node<Integer, Plan | LLMResponseWithPlan, \"Plan\">\n  }>(\n    `\n    MATCH (p:Plan)-[:IMPLEMENTS]->(i:Issue {number: $issueNumber, repoFullName: $repoFullName})\n    RETURN p\n    `,\n    { repoFullName, issueNumber }\n  )\n\n  return result.records.map((record) => {\n    const raw = record.get(\"p\")?.properties\n    return z.union([planSchema, llmResponseWithPlanSchema]).parse(raw)\n  })\n}\n\n// Add :Plan label and properties to Event node\nexport async function labelEventAsPlan(\n  tx: ManagedTransaction,\n  {\n    eventId,\n    status = \"draft\",\n    version = int(1),\n  }: { eventId: string; status?: string; version?: Integer }\n): Promise<LLMResponseWithPlan> {\n  const result = await tx.run<{\n    e: Node<Integer, LLMResponseWithPlan, \"Event | Plan\">\n  }>(\n    `MATCH (e:Event {id: $eventId})\n     SET e:Plan\n     SET e.status = $status\n     SET e.version = $version\n     RETURN e`,\n    { eventId, status, version }\n  )\n\n  const raw = result.records[0]?.get(\"e\")?.properties\n  return llmResponseWithPlanSchema.parse(raw)\n}\n\n// Create :IMPLEMENTS relationship from Plan to Issue\nexport async function createPlanImplementsIssue(\n  tx: ManagedTransaction,\n  {\n    eventId,\n    issueNumber,\n    repoFullName,\n  }: { eventId: string; issueNumber: Integer; repoFullName: string }\n): Promise<{ plan: Plan | LLMResponseWithPlan; issue: Issue }> {\n  const result = await tx.run<{\n    p: Node<Integer, Plan | LLMResponseWithPlan, \"Plan\">\n    i: Node<Integer, Issue, \"Issue\">\n  }>(\n    `MATCH (p:Plan {id: $eventId})\n    OPTIONAL MATCH(i:Issue {number: $issueNumber, repoFullName: $repoFullName})\n     CREATE (p)-[:IMPLEMENTS]->(i)\n     RETURN p, i`,\n    { eventId, issueNumber, repoFullName }\n  )\n  const p = result.records[0]?.get(\"p\")?.properties\n  const i = result.records[0]?.get(\"i\")?.properties\n\n  return {\n    plan: z.union([planSchema, llmResponseWithPlanSchema]).parse(p),\n    issue: issueSchema.parse(i),\n  }\n}\n\n// Convert db-level Plan to app-level Plan (currently passthrough, but for future-proofing)\nexport const toAppPlan = (dbPlan: Plan): AppPlan => {\n  return {\n    ...dbPlan,\n    version: dbPlan.version.toNumber(),\n    createdAt: dbPlan.createdAt.toStandardDate(),\n  }\n}\n\n// Get Plan and related nodes by planId\nexport async function getPlanWithDetails(\n  tx: ManagedTransaction,\n  { planId }: { planId: string }\n) {\n  const result = await tx.run<{\n    p: Node<Integer, Plan | LLMResponseWithPlan, \"Plan\">\n    w: Node<Integer, WorkflowRun, \"WorkflowRun\">\n    i: Node<Integer, Issue, \"Issue\">\n  }>(\n    `\n    MATCH (p:Plan {id: $planId})-[:IMPLEMENTS]->(i:Issue)<-[:BASED_ON_ISSUE]-(w:WorkflowRun)\n    RETURN p, w, i\n    `,\n    { planId }\n  )\n\n  const raw = result.records[0]\n\n  return {\n    plan: planSchema.parse(raw.get(\"p\")?.properties),\n    workflow: workflowRunSchema.parse(raw.get(\"w\")?.properties),\n    issue: issueSchema.parse(raw.get(\"i\")?.properties),\n  }\n}\n\n// Batch plan status for multiple issues\nexport async function listPlanStatusForIssues(\n  tx: ManagedTransaction,\n  {\n    repoFullName,\n    issueNumbers,\n  }: { repoFullName: string; issueNumbers: number[] }\n): Promise<Record<number, boolean>> {\n  if (!issueNumbers.length) return {}\n  const cypher = `\n    MATCH (i:Issue)\n    WHERE i.repoFullName = $repoFullName AND i.number IN $issueNumbers\n    OPTIONAL MATCH (p:Plan)-[:IMPLEMENTS]->(i)\n    RETURN i.number AS number, count(p) > 0 AS hasPlan\n  `\n  const result = await tx.run(cypher, { repoFullName, issueNumbers })\n  const status: Record<number, boolean> = {}\n  for (const record of result.records) {\n    status[record.get(\"number\")] = record.get(\"hasPlan\")\n  }\n  return status\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_D7jADwgaysUdJqHWPLGeODvO",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "e494757c-8abf-496a-aaa0-62a1c98c4463",
    "createdAt": "2025-06-10T06:36:03.056Z",
    "type": "toolCall",
    "toolName": "get_file_content",
    "toolCallId": "call_WpCQi86sdfxMNjMOESx8iOho",
    "args": "{\"relativePath\":\"lib/tools/IssueCommentTool.ts\"}",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  },
  {
    "id": "0842d0c8-7050-43df-94a0-22428c443a3f",
    "createdAt": "2025-06-10T06:36:03.088Z",
    "content": "import { z } from \"zod\"\n\nimport { createIssueComment as createIssueCommentApi } from \"@/lib/github/issues\"\nimport { createTool } from \"@/lib/tools/helper\"\n\nconst issueCommentParameters = z.object({\n  issueNumber: z\n    .number()\n    .describe(\"The issue or PR number to post the comment to\"),\n  repoFullName: z.string().describe(\"The full name of the repo (owner/repo)\"),\n  comment: z.string().describe(\"The comment body to post\"),\n})\n\ntype IssueCommentParams = z.infer<typeof issueCommentParameters>\n\nexport const createIssueCommentTool = (params: Partial<IssueCommentParams>) => {\n  // Identify which params have been provided\n  const providedKeys = Object.keys(params).filter(\n    (key) => params[key as keyof IssueCommentParams] !== undefined\n  ) as (keyof IssueCommentParams)[]\n\n  // Omit provided params from the schema\n  const updatedSchema = issueCommentParameters.omit(\n    providedKeys.reduce(\n      (acc, key) => {\n        acc[key] = true\n        return acc\n      },\n      {} as Record<keyof IssueCommentParams, true>\n    )\n  )\n\n  return createTool<typeof updatedSchema, string>({\n    name: \"create_issue_comment\",\n    description:\n      \"Posts a comment to a GitHub issue or PR (PRs are issues in the GitHub API).\",\n    schema: updatedSchema,\n    handler: async (newParams: z.infer<typeof updatedSchema>) => {\n      const mergedParams = { ...params, ...newParams }\n      const { issueNumber, repoFullName, comment } =\n        issueCommentParameters.parse(mergedParams)\n      const result = await createIssueCommentApi({\n        issueNumber,\n        repoFullName,\n        comment,\n      })\n      return JSON.stringify(result)\n    },\n  })\n}\n",
    "type": "toolCallResult",
    "toolCallId": "call_WpCQi86sdfxMNjMOESx8iOho",
    "toolName": "get_file_content",
    "workflowId": "c9680923-ebc4-4e78-8165-f25d0c7e3c65"
  }
]
